<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Relations: Inductive definition of relations | Programming Language Foundations in Agda</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="Relations: Inductive definition of relations" />
<meta name="author" content="Wen Kokke" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Programming Language Foundations in Agda" />
<meta property="og:description" content="Programming Language Foundations in Agda" />
<link rel="canonical" href="https://plfa.ed.inf.ac.uk/Relations/" />
<meta property="og:url" content="https://plfa.ed.inf.ac.uk/Relations/" />
<meta property="og:site_name" content="Programming Language Foundations in Agda" />
<script type="application/ld+json">
{"description":"Programming Language Foundations in Agda","author":{"@type":"Person","name":"Wen Kokke"},"@type":"WebPage","url":"https://plfa.ed.inf.ac.uk/Relations/","headline":"Relations: Inductive definition of relations","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://plfa.ed.inf.ac.uk/feed.xml" title="Programming Language Foundations in Agda
" /></head>
<body><header class="site-header" role="banner">

    <div class="wrapper">

        <a class="site-title" href="/">Programming Language Foundations in Agda
</a>

        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="/">Table of Contents</a>
                <a class="page-link" href="/about/">About</a>
            </div>
        </nav>

    </div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Relations: Inductive definition of relations</h1>
  </header>

  <div class="post-content">
    <pre class="Agda"><a id="123" class="Keyword">module</a> <a id="130" href="/Relations/" class="Module">plfa.Relations</a> <a id="145" class="Keyword">where</a></pre>

<p>After having defined operations such as addition and multiplication,
the next step is to define relations, such as <em>less than or equal</em>.</p>

<h2 id="imports">Imports</h2>

<pre class="Agda"><a id="326" class="Keyword">import</a> <a id="333" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="371" class="Symbol">as</a> <a id="374" class="Module">Eq</a>
<a id="377" class="Keyword">open</a> <a id="382" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="385" class="Keyword">using</a> <a id="391" class="Symbol">(</a><a id="392" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">_≡_</a><a id="395" class="Symbol">;</a> <a id="397" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="401" class="Symbol">;</a> <a id="403" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1075" class="Function">cong</a><a id="407" class="Symbol">;</a> <a id="409" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#560" class="Function">sym</a><a id="412" class="Symbol">)</a>
<a id="414" class="Keyword">open</a> <a id="419" class="Keyword">import</a> <a id="426" href="https://agda.github.io/agda-stdlib/Data.Nat.html" class="Module">Data.Nat</a> <a id="435" class="Keyword">using</a> <a id="441" class="Symbol">(</a><a id="442" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="443" class="Symbol">;</a> <a id="445" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a><a id="449" class="Symbol">;</a> <a id="451" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a><a id="454" class="Symbol">;</a> <a id="456" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a><a id="459" class="Symbol">;</a> <a id="461" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#433" class="Primitive Operator">_*_</a><a id="464" class="Symbol">;</a> <a id="466" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#320" class="Primitive Operator">_∸_</a><a id="469" class="Symbol">)</a>
<a id="471" class="Keyword">open</a> <a id="476" class="Keyword">import</a> <a id="483" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="503" class="Keyword">using</a> <a id="509" class="Symbol">(</a><a id="510" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#8115" class="Function">+-comm</a><a id="516" class="Symbol">;</a> <a id="518" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#7679" class="Function">+-suc</a><a id="523" class="Symbol">)</a></pre>

<h2 id="defining-relations">Defining relations</h2>

<p>The relation <em>less than or equal</em> has an infinite number of
instances.  Here are a few of them:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 ≤ 0     0 ≤ 1     0 ≤ 2     0 ≤ 3     ...
          1 ≤ 1     1 ≤ 2     1 ≤ 3     ...
                    2 ≤ 2     2 ≤ 3     ...
                              3 ≤ 3     ...
                                        ...
</code></pre></div></div>

<p>And yet, we can write a finite definition that encompasses
all of these instances in just a few lines.  Here is the
definition as a pair of inference rules:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>z≤n --------
    zero ≤ n

    m ≤ n
s≤s -------------
    suc m ≤ suc n
</code></pre></div></div>

<p>And here is the definition in Agda:</p>
<pre class="Agda"><a id="1200" class="Keyword">data</a> <a id="_≤_"></a><a id="1205" href="/Relations/#1205" class="Datatype Operator">_≤_</a> <a id="1209" class="Symbol">:</a> <a id="1211" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a> <a id="1213" class="Symbol">→</a> <a id="1215" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a> <a id="1217" class="Symbol">→</a> <a id="1219" class="PrimitiveType">Set</a> <a id="1223" class="Keyword">where</a>
  <a id="_≤_.z≤n"></a><a id="1231" href="/Relations/#1231" class="InductiveConstructor">z≤n</a> <a id="1235" class="Symbol">:</a> <a id="1237" class="Symbol">∀</a> <a id="1239" class="Symbol">{</a><a id="1240" href="/Relations/#1240" class="Bound">m</a> <a id="1242" class="Symbol">:</a> <a id="1244" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="1245" class="Symbol">}</a> <a id="1247" class="Symbol">→</a> <a id="1249" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a> <a id="1254" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="1256" href="/Relations/#1240" class="Bound">m</a>
  <a id="_≤_.s≤s"></a><a id="1260" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="1264" class="Symbol">:</a> <a id="1266" class="Symbol">∀</a> <a id="1268" class="Symbol">{</a><a id="1269" href="/Relations/#1269" class="Bound">m</a> <a id="1271" href="/Relations/#1271" class="Bound">n</a> <a id="1273" class="Symbol">:</a> <a id="1275" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="1276" class="Symbol">}</a> <a id="1278" class="Symbol">→</a> <a id="1280" href="/Relations/#1269" class="Bound">m</a> <a id="1282" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="1284" href="/Relations/#1271" class="Bound">n</a> <a id="1286" class="Symbol">→</a> <a id="1288" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="1292" href="/Relations/#1269" class="Bound">m</a> <a id="1294" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="1296" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="1300" href="/Relations/#1271" class="Bound">n</a></pre>
<p>Here <code class="highlighter-rouge">z≤n</code> and <code class="highlighter-rouge">s≤s</code> (with no spaces) are constructor names,
while <code class="highlighter-rouge">zero ≤ m</code>, and <code class="highlighter-rouge">m ≤ n</code> and <code class="highlighter-rouge">suc m ≤ suc n</code> (with spaces)
are types.  This is our first use of an <em>indexed</em> datatype,
where we say the type <code class="highlighter-rouge">m ≤ n</code> is indexed by two naturals, <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">n</code>.</p>

<p>Both definitions above tell us the same two things:</p>

<ul>
  <li><em>Base case</em>: for all naturals <code class="highlighter-rouge">n</code>, the proposition <code class="highlighter-rouge">zero ≤ n</code> holds</li>
  <li><em>Inductive case</em>: for all naturals <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">n</code>, if the proposition
<code class="highlighter-rouge">m ≤ n</code> holds, then the proposition <code class="highlighter-rouge">suc m ≤ suc n</code> holds.</li>
</ul>

<p>In fact, they each give us a bit more detail:</p>

<ul>
  <li><em>Base case</em>: for all naturals <code class="highlighter-rouge">n</code>, the constructor <code class="highlighter-rouge">z≤n</code>
produces evidence that <code class="highlighter-rouge">zero ≤ n</code> holds.</li>
  <li><em>Inductive case</em>: for all naturals <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">n</code>, the constructor
<code class="highlighter-rouge">s≤s</code> takes evidence that <code class="highlighter-rouge">m ≤ n</code> holds into evidence that
<code class="highlighter-rouge">suc m ≤ suc n</code> holds.</li>
</ul>

<p>For example, here in inference rule notation is the proof that
<code class="highlighter-rouge">2 ≤ 4</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  z≤n -----
      0 ≤ 2
 s≤s -------
      1 ≤ 3
s≤s ---------
      2 ≤ 4
</code></pre></div></div>

<p>And here is the corresponding Agda proof.</p>
<pre class="Agda"><a id="2354" href="/Relations/#2354" class="Function">_</a> <a id="2356" class="Symbol">:</a> <a id="2358" class="Number">2</a> <a id="2360" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="2362" class="Number">4</a>
<a id="2364" class="Symbol">_</a> <a id="2366" class="Symbol">=</a> <a id="2368" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="2372" class="Symbol">(</a><a id="2373" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="2377" href="/Relations/#1231" class="InductiveConstructor">z≤n</a><a id="2380" class="Symbol">)</a></pre>

<h2 id="implicit-arguments">Implicit arguments</h2>

<p>This is our first use of implicit arguments.
In the definition of inequality, the two lines defining the constructors
use <code class="highlighter-rouge">∀</code>, very similar to our use of <code class="highlighter-rouge">∀</code> in propositions such as:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+-comm : ∀ (m n : ℕ) → m + n ≡ n + m
</code></pre></div></div>

<p>However, here the declarations are surrounded by curly braces <code class="highlighter-rouge">{ }</code> rather than
parentheses <code class="highlighter-rouge">( )</code>.  This means that the arguments are <em>implicit</em> and need not be
written explicitly; instead, they are <em>inferred</em> by Agda’s typechecker. Thus, we
write <code class="highlighter-rouge">+-comm m n</code> for the proof that <code class="highlighter-rouge">m + n ≡ n + m</code>, but <code class="highlighter-rouge">z≤n</code> for the proof
that <code class="highlighter-rouge">zero ≤ m</code>, leaving <code class="highlighter-rouge">m</code> implicit.  Similarly, if <code class="highlighter-rouge">m≤n</code> is evidence that
<code class="highlighter-rouge">m ≤ n</code>, we write <code class="highlighter-rouge">s≤s m≤n</code> for evidence that <code class="highlighter-rouge">suc m ≤ suc n</code>, leaving
both <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">n</code> implicit.</p>

<p>If we wish, it is possible to provide implicit arguments explicitly by
writing the arguments inside curly braces.  For instance, here is the
Agda proof that <code class="highlighter-rouge">2 ≤ 4</code> repeated, with the implicit arguments made
explicit.</p>
<pre class="Agda"><a id="3372" href="/Relations/#3372" class="Function">_</a> <a id="3374" class="Symbol">:</a> <a id="3376" class="Number">2</a> <a id="3378" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="3380" class="Number">4</a>
<a id="3382" class="Symbol">_</a> <a id="3384" class="Symbol">=</a> <a id="3386" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="3390" class="Symbol">{</a><a id="3391" class="Number">1</a><a id="3392" class="Symbol">}</a> <a id="3394" class="Symbol">{</a><a id="3395" class="Number">3</a><a id="3396" class="Symbol">}</a> <a id="3398" class="Symbol">(</a><a id="3399" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="3403" class="Symbol">{</a><a id="3404" class="Number">0</a><a id="3405" class="Symbol">}</a> <a id="3407" class="Symbol">{</a><a id="3408" class="Number">2</a><a id="3409" class="Symbol">}</a> <a id="3411" class="Symbol">(</a><a id="3412" href="/Relations/#1231" class="InductiveConstructor">z≤n</a> <a id="3416" class="Symbol">{</a><a id="3417" class="Number">2</a><a id="3418" class="Symbol">}))</a></pre>

<h2 id="precedence">Precedence</h2>

<p>We declare the precedence for comparison as follows.</p>
<pre class="Agda"><a id="3516" class="Keyword">infix</a> <a id="3522" class="Number">4</a> <a id="3524" href="/Relations/#1205" class="Datatype Operator">_≤_</a></pre>
<p>We set the precedence of <code class="highlighter-rouge">_≤_</code> at level 4, so it binds less tightly
that <code class="highlighter-rouge">_+_</code> at level 6 and hence <code class="highlighter-rouge">1 + 2 ≤ 3</code> parses as <code class="highlighter-rouge">(1 + 2) ≤ 3</code>.
We write <code class="highlighter-rouge">infix</code> to indicate that the operator does not associate to
either the left or right, as it makes no sense to parse <code class="highlighter-rouge">1 ≤ 2 ≤ 3</code> as
either <code class="highlighter-rouge">(1 ≤ 2) ≤ 3</code> or <code class="highlighter-rouge">1 ≤ (2 ≤ 3)</code>.</p>

<h2 id="decidability">Decidability</h2>

<p>Given two numbers, it is straightforward to compute whether or not the first is
less than or equal to the second.  We don’t give the code for doing so here, but
will return to this point in Chapter <a href="/Decidable/">Decidable</a>.</p>

<h2 id="properties-of-ordering-relations">Properties of ordering relations</h2>

<p>Relations occur all the time, and mathematicians have agreed
on names for some of the most common properties.</p>

<ul>
  <li><em>Reflexive</em> For all <code class="highlighter-rouge">n</code>, the relation <code class="highlighter-rouge">n ≤ n</code> holds.</li>
  <li><em>Transitive</em> For all <code class="highlighter-rouge">m</code>, <code class="highlighter-rouge">n</code>, and <code class="highlighter-rouge">p</code>, if <code class="highlighter-rouge">m ≤ n</code> and
<code class="highlighter-rouge">n ≤ p</code> hold, then <code class="highlighter-rouge">m ≤ p</code> holds.</li>
  <li><em>Anti-symmetric</em> For all <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">n</code>, if both <code class="highlighter-rouge">m ≤ n</code> and
<code class="highlighter-rouge">n ≤ m</code> hold, then <code class="highlighter-rouge">m ≡ n</code> holds.</li>
  <li><em>Total</em> For all <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">n</code>, either <code class="highlighter-rouge">m ≤ n</code> or <code class="highlighter-rouge">n ≤ m</code>
holds.</li>
</ul>

<p>The relation <code class="highlighter-rouge">_≤_</code> satisfies all four of these properties.</p>

<p>There are also names for some combinations of these properties.</p>

<ul>
  <li><em>Preorder</em> Any relation that is reflexive and transitive.</li>
  <li><em>Partial order</em> Any preorder that is also anti-symmetric.</li>
  <li><em>Total order</em> Any partial order that is also total.</li>
</ul>

<p>If you ever bump into a relation at a party, you now know how
to make small talk, by asking it whether it is reflexive, transitive,
anti-symmetric, and total. Or instead you might ask whether it is a
preorder, partial order, or total order.</p>

<p>Less frivolously, if you ever bump into a relation while reading
a technical paper, this gives you an easy way to orient yourself,
by checking whether or not it is a preorder, partial order, or total order.
A careful author will often make it explicit, for instance by saying
that a given relation is a preorder but not a partial order, or a
partial order but not a total order. (Can you think of examples of
such relations?)</p>

<h2 id="reflexivity">Reflexivity</h2>

<p>The first property to prove about comparison is that it is reflexive:
for any natural <code class="highlighter-rouge">n</code>, the relation <code class="highlighter-rouge">n ≤ n</code> holds.</p>
<pre class="Agda"><a id="≤-refl"></a><a id="5710" href="/Relations/#5710" class="Function">≤-refl</a> <a id="5717" class="Symbol">:</a> <a id="5719" class="Symbol">∀</a> <a id="5721" class="Symbol">{</a><a id="5722" href="/Relations/#5722" class="Bound">n</a> <a id="5724" class="Symbol">:</a> <a id="5726" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="5727" class="Symbol">}</a> <a id="5729" class="Symbol">→</a> <a id="5731" href="/Relations/#5722" class="Bound">n</a> <a id="5733" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="5735" href="/Relations/#5722" class="Bound">n</a>
<a id="5737" href="/Relations/#5710" class="Function">≤-refl</a> <a id="5744" class="Symbol">{</a><a id="5745" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a><a id="5749" class="Symbol">}</a> <a id="5751" class="Symbol">=</a> <a id="5753" href="/Relations/#1231" class="InductiveConstructor">z≤n</a>
<a id="5757" href="/Relations/#5710" class="Function">≤-refl</a> <a id="5764" class="Symbol">{</a><a id="5765" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="5769" href="/Relations/#5769" class="Bound">n</a><a id="5770" class="Symbol">}</a> <a id="5772" class="Symbol">=</a> <a id="5774" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="5778" class="Symbol">(</a><a id="5779" href="/Relations/#5710" class="Function">≤-refl</a> <a id="5786" class="Symbol">{</a><a id="5787" href="/Relations/#5769" class="Bound">n</a><a id="5788" class="Symbol">})</a></pre>
<p>The proof is a straightforward induction on <code class="highlighter-rouge">n</code>.  In the base case,
<code class="highlighter-rouge">zero ≤ zero</code> holds by <code class="highlighter-rouge">z≤n</code>.  In the inductive case, the inductive
hypothesis <code class="highlighter-rouge">≤-refl n</code> gives us a proof of <code class="highlighter-rouge">n ≤ n</code>, and applying <code class="highlighter-rouge">s≤s</code>
to that yields a proof of <code class="highlighter-rouge">suc n ≤ suc n</code>.</p>

<p>It is a good exercise to prove reflexivity interactively in Emacs,
using holes and the <code class="highlighter-rouge">^C ^C</code>, <code class="highlighter-rouge">^C ^,</code>, and <code class="highlighter-rouge">^C ^R</code> commands.</p>

<h2 id="transitivity">Transitivity</h2>

<p>The second property to prove about comparison is that it is
transitive: for any naturals <code class="highlighter-rouge">m</code>, <code class="highlighter-rouge">n</code>, and <code class="highlighter-rouge">p</code>, if <code class="highlighter-rouge">m ≤ n</code> and <code class="highlighter-rouge">n ≤
p</code> hold, then <code class="highlighter-rouge">m ≤ p</code> holds.</p>
<pre class="Agda"><a id="≤-trans"></a><a id="6368" href="/Relations/#6368" class="Function">≤-trans</a> <a id="6376" class="Symbol">:</a> <a id="6378" class="Symbol">∀</a> <a id="6380" class="Symbol">{</a><a id="6381" href="/Relations/#6381" class="Bound">m</a> <a id="6383" href="/Relations/#6383" class="Bound">n</a> <a id="6385" href="/Relations/#6385" class="Bound">p</a> <a id="6387" class="Symbol">:</a> <a id="6389" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="6390" class="Symbol">}</a> <a id="6392" class="Symbol">→</a> <a id="6394" href="/Relations/#6381" class="Bound">m</a> <a id="6396" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="6398" href="/Relations/#6383" class="Bound">n</a> <a id="6400" class="Symbol">→</a> <a id="6402" href="/Relations/#6383" class="Bound">n</a> <a id="6404" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="6406" href="/Relations/#6385" class="Bound">p</a> <a id="6408" class="Symbol">→</a> <a id="6410" href="/Relations/#6381" class="Bound">m</a> <a id="6412" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="6414" href="/Relations/#6385" class="Bound">p</a>
<a id="6416" href="/Relations/#6368" class="Function">≤-trans</a> <a id="6424" href="/Relations/#1231" class="InductiveConstructor">z≤n</a> <a id="6428" class="Symbol">_</a> <a id="6430" class="Symbol">=</a> <a id="6432" href="/Relations/#1231" class="InductiveConstructor">z≤n</a>
<a id="6436" href="/Relations/#6368" class="Function">≤-trans</a> <a id="6444" class="Symbol">(</a><a id="6445" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="6449" href="/Relations/#6449" class="Bound">m≤n</a><a id="6452" class="Symbol">)</a> <a id="6454" class="Symbol">(</a><a id="6455" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="6459" href="/Relations/#6459" class="Bound">n≤p</a><a id="6462" class="Symbol">)</a> <a id="6464" class="Symbol">=</a> <a id="6466" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="6470" class="Symbol">(</a><a id="6471" href="/Relations/#6368" class="Function">≤-trans</a> <a id="6479" href="/Relations/#6449" class="Bound">m≤n</a> <a id="6483" href="/Relations/#6459" class="Bound">n≤p</a><a id="6486" class="Symbol">)</a></pre>
<p>Here the proof is most easily thought of as by induction on the
<em>evidence</em> that <code class="highlighter-rouge">m ≤ n</code>, so we have left <code class="highlighter-rouge">m</code>, <code class="highlighter-rouge">n</code>, and <code class="highlighter-rouge">p</code> implicit.</p>

<p>In the base case, the first inequality holds by <code class="highlighter-rouge">z≤n</code>, and so
we are given <code class="highlighter-rouge">zero ≤ n</code> and <code class="highlighter-rouge">n ≤ p</code> and must show <code class="highlighter-rouge">zero ≤ p</code>,
which follows immediately by <code class="highlighter-rouge">z≤n</code>.  In this
case, the fact that <code class="highlighter-rouge">n ≤ p</code> is irrelevant, and we write <code class="highlighter-rouge">_</code> as the
pattern to indicate that the corresponding evidence is unused.</p>

<p>In the inductive case, the first inequality holds by <code class="highlighter-rouge">s≤s m≤n</code>
and the second inequality by <code class="highlighter-rouge">s≤s n≤p</code>, and so we are given
<code class="highlighter-rouge">suc m ≤ suc n</code> and <code class="highlighter-rouge">suc n ≤ suc p</code>, and must show <code class="highlighter-rouge">suc m ≤ suc p</code>.
The inductive hypothesis <code class="highlighter-rouge">≤-trans m≤n n≤p</code> establishes
that <code class="highlighter-rouge">m ≤ p</code>, and our goal follows by applying <code class="highlighter-rouge">s≤s</code>.</p>

<p>The case <code class="highlighter-rouge">≤-trans (s≤s m≤n) z≤n</code> cannot arise, since the first
inequality implies the middle value is <code class="highlighter-rouge">suc n</code> while the second
inequality implies that it is <code class="highlighter-rouge">zero</code>.  Agda can determine that
such a case cannot arise, and does not require it to be listed.</p>

<p>Alternatively, we could make the implicit parameters explicit.</p>
<pre class="Agda"><a id="≤-trans′"></a><a id="7565" href="/Relations/#7565" class="Function">≤-trans′</a> <a id="7574" class="Symbol">:</a> <a id="7576" class="Symbol">∀</a> <a id="7578" class="Symbol">(</a><a id="7579" href="/Relations/#7579" class="Bound">m</a> <a id="7581" href="/Relations/#7581" class="Bound">n</a> <a id="7583" href="/Relations/#7583" class="Bound">p</a> <a id="7585" class="Symbol">:</a> <a id="7587" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="7588" class="Symbol">)</a> <a id="7590" class="Symbol">→</a> <a id="7592" href="/Relations/#7579" class="Bound">m</a> <a id="7594" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="7596" href="/Relations/#7581" class="Bound">n</a> <a id="7598" class="Symbol">→</a> <a id="7600" href="/Relations/#7581" class="Bound">n</a> <a id="7602" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="7604" href="/Relations/#7583" class="Bound">p</a> <a id="7606" class="Symbol">→</a> <a id="7608" href="/Relations/#7579" class="Bound">m</a> <a id="7610" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="7612" href="/Relations/#7583" class="Bound">p</a>
<a id="7614" href="/Relations/#7565" class="Function">≤-trans′</a> <a id="7623" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a> <a id="7628" href="/Relations/#7628" class="Bound">n</a> <a id="7630" href="/Relations/#7630" class="Bound">p</a> <a id="7632" href="/Relations/#1231" class="InductiveConstructor">z≤n</a> <a id="7636" class="Symbol">_</a> <a id="7638" class="Symbol">=</a> <a id="7640" href="/Relations/#1231" class="InductiveConstructor">z≤n</a>
<a id="7644" href="/Relations/#7565" class="Function">≤-trans′</a> <a id="7653" class="Symbol">(</a><a id="7654" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="7658" href="/Relations/#7658" class="Bound">m</a><a id="7659" class="Symbol">)</a> <a id="7661" class="Symbol">(</a><a id="7662" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="7666" href="/Relations/#7666" class="Bound">n</a><a id="7667" class="Symbol">)</a> <a id="7669" class="Symbol">(</a><a id="7670" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="7674" href="/Relations/#7674" class="Bound">p</a><a id="7675" class="Symbol">)</a> <a id="7677" class="Symbol">(</a><a id="7678" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="7682" href="/Relations/#7682" class="Bound">m≤n</a><a id="7685" class="Symbol">)</a> <a id="7687" class="Symbol">(</a><a id="7688" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="7692" href="/Relations/#7692" class="Bound">n≤p</a><a id="7695" class="Symbol">)</a> <a id="7697" class="Symbol">=</a> <a id="7699" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="7703" class="Symbol">(</a><a id="7704" href="/Relations/#7565" class="Function">≤-trans′</a> <a id="7713" href="/Relations/#7658" class="Bound">m</a> <a id="7715" href="/Relations/#7666" class="Bound">n</a> <a id="7717" href="/Relations/#7674" class="Bound">p</a> <a id="7719" href="/Relations/#7682" class="Bound">m≤n</a> <a id="7723" href="/Relations/#7692" class="Bound">n≤p</a><a id="7726" class="Symbol">)</a></pre>
<p>One might argue that this is clearer or one might argue that the extra
length obscures the essence of the proof.  We will usually opt for
shorter proofs.</p>

<p>The technique of inducting on evidence that a property holds (e.g.,
inducting on evidence that <code class="highlighter-rouge">m ≤ n</code>)—rather than induction on the
value of which the property holds (e.g., inducting on <code class="highlighter-rouge">m</code>)—will turn
out to be immensely valuable, and one that we use often.</p>

<p>Again, it is a good exercise to prove transitivity interactively in Emacs,
using holes and the <code class="highlighter-rouge">^C ^C</code>, <code class="highlighter-rouge">^C ^,</code>, and <code class="highlighter-rouge">^C ^R</code> commands.</p>

<h2 id="anti-symmetry">Anti-symmetry</h2>

<p>The third property to prove about comparison is that it is antisymmetric:
for all naturals <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">n</code>, if both <code class="highlighter-rouge">m ≤ n</code> and <code class="highlighter-rouge">n ≤ m</code> hold, then
<code class="highlighter-rouge">m ≡ n</code> holds.</p>
<pre class="Agda"><a id="≤-antisym"></a><a id="8484" href="/Relations/#8484" class="Function">≤-antisym</a> <a id="8494" class="Symbol">:</a> <a id="8496" class="Symbol">∀</a> <a id="8498" class="Symbol">{</a><a id="8499" href="/Relations/#8499" class="Bound">m</a> <a id="8501" href="/Relations/#8501" class="Bound">n</a> <a id="8503" class="Symbol">:</a> <a id="8505" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="8506" class="Symbol">}</a> <a id="8508" class="Symbol">→</a> <a id="8510" href="/Relations/#8499" class="Bound">m</a> <a id="8512" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="8514" href="/Relations/#8501" class="Bound">n</a> <a id="8516" class="Symbol">→</a> <a id="8518" href="/Relations/#8501" class="Bound">n</a> <a id="8520" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="8522" href="/Relations/#8499" class="Bound">m</a> <a id="8524" class="Symbol">→</a> <a id="8526" href="/Relations/#8499" class="Bound">m</a> <a id="8528" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="8530" href="/Relations/#8501" class="Bound">n</a>
<a id="8532" href="/Relations/#8484" class="Function">≤-antisym</a> <a id="8542" href="/Relations/#1231" class="InductiveConstructor">z≤n</a> <a id="8546" href="/Relations/#1231" class="InductiveConstructor">z≤n</a> <a id="8550" class="Symbol">=</a> <a id="8552" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="8557" href="/Relations/#8484" class="Function">≤-antisym</a> <a id="8567" class="Symbol">(</a><a id="8568" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="8572" href="/Relations/#8572" class="Bound">m≤n</a><a id="8575" class="Symbol">)</a> <a id="8577" class="Symbol">(</a><a id="8578" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="8582" href="/Relations/#8582" class="Bound">n≤m</a><a id="8585" class="Symbol">)</a> <a id="8587" class="Symbol">=</a> <a id="8589" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1075" class="Function">cong</a> <a id="8594" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="8598" class="Symbol">(</a><a id="8599" href="/Relations/#8484" class="Function">≤-antisym</a> <a id="8609" href="/Relations/#8572" class="Bound">m≤n</a> <a id="8613" href="/Relations/#8582" class="Bound">n≤m</a><a id="8616" class="Symbol">)</a></pre>
<p>Again, the proof is by induction over the evidence that <code class="highlighter-rouge">m ≤ n</code>
and <code class="highlighter-rouge">n ≤ m</code> hold, and so we have left <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">n</code> implicit.</p>

<p>In the base case, both inequalities hold by <code class="highlighter-rouge">z≤n</code>,
and so we are given <code class="highlighter-rouge">zero ≤ zero</code> and <code class="highlighter-rouge">zero ≤ zero</code> and must
show <code class="highlighter-rouge">zero ≡ zero</code>, which follows by reflexivity.  (Reflexivity
of equality, that is, not reflexivity of inequality.)</p>

<p>In the inductive case, the first inequality holds by <code class="highlighter-rouge">s≤s m≤n</code>
and the second inequality holds by <code class="highlighter-rouge">s≤s n≤m</code>, and so we are
given <code class="highlighter-rouge">suc m ≤ suc n</code> and <code class="highlighter-rouge">suc n ≤ suc m</code> and must show <code class="highlighter-rouge">suc m ≡ suc n</code>.
The inductive hypothesis <code class="highlighter-rouge">≤-antisym m≤n n≤m</code> establishes that <code class="highlighter-rouge">m ≡ n</code>,
and our goal follows by congruence.</p>

<h3 id="exercise--antisym-cases">Exercise (≤-antisym-cases)</h3>

<p>The above proof omits cases where one argument is <code class="highlighter-rouge">z≤n</code> and one
argument is <code class="highlighter-rouge">s≤s</code>.  Why is it ok to omit them?</p>

<h2 id="total">Total</h2>

<p>The fourth property to prove about comparison is that it is total:
for any naturals <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">n</code> either <code class="highlighter-rouge">m ≤ n</code> or <code class="highlighter-rouge">n ≤ m</code>, or both if
<code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">n</code> are equal.</p>

<p>We specify what it means for inequality to be total.</p>
<pre class="Agda"><a id="9668" class="Keyword">data</a> <a id="Total"></a><a id="9673" href="/Relations/#9673" class="Datatype">Total</a> <a id="9679" class="Symbol">(</a><a id="9680" href="/Relations/#9680" class="Bound">m</a> <a id="9682" href="/Relations/#9682" class="Bound">n</a> <a id="9684" class="Symbol">:</a> <a id="9686" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="9687" class="Symbol">)</a> <a id="9689" class="Symbol">:</a> <a id="9691" class="PrimitiveType">Set</a> <a id="9695" class="Keyword">where</a>
  <a id="Total.forward"></a><a id="9703" href="/Relations/#9703" class="InductiveConstructor">forward</a> <a id="9711" class="Symbol">:</a> <a id="9713" href="/Relations/#9680" class="Bound">m</a> <a id="9715" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="9717" href="/Relations/#9682" class="Bound">n</a> <a id="9719" class="Symbol">→</a> <a id="9721" href="/Relations/#9673" class="Datatype">Total</a> <a id="9727" href="/Relations/#9680" class="Bound">m</a> <a id="9729" href="/Relations/#9682" class="Bound">n</a>
  <a id="Total.flipped"></a><a id="9733" href="/Relations/#9733" class="InductiveConstructor">flipped</a> <a id="9741" class="Symbol">:</a> <a id="9743" href="/Relations/#9682" class="Bound">n</a> <a id="9745" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="9747" href="/Relations/#9680" class="Bound">m</a> <a id="9749" class="Symbol">→</a> <a id="9751" href="/Relations/#9673" class="Datatype">Total</a> <a id="9757" href="/Relations/#9680" class="Bound">m</a> <a id="9759" href="/Relations/#9682" class="Bound">n</a></pre>
<p>Evidence that <code class="highlighter-rouge">Total m n</code> holds is either of the form
<code class="highlighter-rouge">forward m≤n</code> or <code class="highlighter-rouge">flipped n≤m</code>, where <code class="highlighter-rouge">m≤n</code> and <code class="highlighter-rouge">n≤m</code> are
evidence of <code class="highlighter-rouge">m ≤ n</code> and <code class="highlighter-rouge">n ≤ m</code> respectively.</p>

<p>This is our first use of a datatype with <em>parameters</em>,
in this case <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">n</code>.  It is equivalent to the following
indexed datatype.</p>
<pre class="Agda"><a id="10078" class="Keyword">data</a> <a id="Total′"></a><a id="10083" href="/Relations/#10083" class="Datatype">Total′</a> <a id="10090" class="Symbol">:</a> <a id="10092" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a> <a id="10094" class="Symbol">→</a> <a id="10096" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a> <a id="10098" class="Symbol">→</a> <a id="10100" class="PrimitiveType">Set</a> <a id="10104" class="Keyword">where</a>
  <a id="Total′.forward′"></a><a id="10112" href="/Relations/#10112" class="InductiveConstructor">forward′</a> <a id="10121" class="Symbol">:</a> <a id="10123" class="Symbol">∀</a> <a id="10125" class="Symbol">{</a><a id="10126" href="/Relations/#10126" class="Bound">m</a> <a id="10128" href="/Relations/#10128" class="Bound">n</a> <a id="10130" class="Symbol">:</a> <a id="10132" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="10133" class="Symbol">}</a> <a id="10135" class="Symbol">→</a> <a id="10137" href="/Relations/#10126" class="Bound">m</a> <a id="10139" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="10141" href="/Relations/#10128" class="Bound">n</a> <a id="10143" class="Symbol">→</a> <a id="10145" href="/Relations/#10083" class="Datatype">Total′</a> <a id="10152" href="/Relations/#10126" class="Bound">m</a> <a id="10154" href="/Relations/#10128" class="Bound">n</a>
  <a id="Total′.flipped′"></a><a id="10158" href="/Relations/#10158" class="InductiveConstructor">flipped′</a> <a id="10167" class="Symbol">:</a> <a id="10169" class="Symbol">∀</a> <a id="10171" class="Symbol">{</a><a id="10172" href="/Relations/#10172" class="Bound">m</a> <a id="10174" href="/Relations/#10174" class="Bound">n</a> <a id="10176" class="Symbol">:</a> <a id="10178" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="10179" class="Symbol">}</a> <a id="10181" class="Symbol">→</a> <a id="10183" href="/Relations/#10174" class="Bound">n</a> <a id="10185" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="10187" href="/Relations/#10172" class="Bound">m</a> <a id="10189" class="Symbol">→</a> <a id="10191" href="/Relations/#10083" class="Datatype">Total′</a> <a id="10198" href="/Relations/#10172" class="Bound">m</a> <a id="10200" href="/Relations/#10174" class="Bound">n</a></pre>
<p>Each parameter of the type translates as an implicit
parameter of each constructor.
Unlike an indexed datatype, where the indexes can vary
(as in <code class="highlighter-rouge">zero ≤ n</code> and <code class="highlighter-rouge">suc m ≤ suc n</code>), in a parameterised
datatype the parameters must always be the same (as in <code class="highlighter-rouge">Total m n</code>).
Parameterised declarations are shorter, easier to read, and let Agda
exploit the uniformity of the parameters, so we will use them in
preference to indexed types when possible.</p>

<p>With that preliminary out of the way, we specify and prove totality.</p>
<pre class="Agda"><a id="≤-total"></a><a id="10740" href="/Relations/#10740" class="Function">≤-total</a> <a id="10748" class="Symbol">:</a> <a id="10750" class="Symbol">∀</a> <a id="10752" class="Symbol">(</a><a id="10753" href="/Relations/#10753" class="Bound">m</a> <a id="10755" href="/Relations/#10755" class="Bound">n</a> <a id="10757" class="Symbol">:</a> <a id="10759" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="10760" class="Symbol">)</a> <a id="10762" class="Symbol">→</a> <a id="10764" href="/Relations/#9673" class="Datatype">Total</a> <a id="10770" href="/Relations/#10753" class="Bound">m</a> <a id="10772" href="/Relations/#10755" class="Bound">n</a>
<a id="10774" href="/Relations/#10740" class="Function">≤-total</a> <a id="10782" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a>    <a id="10790" href="/Relations/#10790" class="Bound">n</a>                         <a id="10816" class="Symbol">=</a>  <a id="10819" href="/Relations/#9703" class="InductiveConstructor">forward</a> <a id="10827" href="/Relations/#1231" class="InductiveConstructor">z≤n</a>
<a id="10831" href="/Relations/#10740" class="Function">≤-total</a> <a id="10839" class="Symbol">(</a><a id="10840" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="10844" href="/Relations/#10844" class="Bound">m</a><a id="10845" class="Symbol">)</a> <a id="10847" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a>                      <a id="10873" class="Symbol">=</a>  <a id="10876" href="/Relations/#9733" class="InductiveConstructor">flipped</a> <a id="10884" href="/Relations/#1231" class="InductiveConstructor">z≤n</a>
<a id="10888" href="/Relations/#10740" class="Function">≤-total</a> <a id="10896" class="Symbol">(</a><a id="10897" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="10901" href="/Relations/#10901" class="Bound">m</a><a id="10902" class="Symbol">)</a> <a id="10904" class="Symbol">(</a><a id="10905" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="10909" href="/Relations/#10909" class="Bound">n</a><a id="10910" class="Symbol">)</a> <a id="10912" class="Keyword">with</a> <a id="10917" href="/Relations/#10740" class="Function">≤-total</a> <a id="10925" href="/Relations/#10901" class="Bound">m</a> <a id="10927" href="/Relations/#10909" class="Bound">n</a>
<a id="10929" class="Symbol">...</a>                        <a id="10956" class="Symbol">|</a> <a id="10958" href="/Relations/#9703" class="InductiveConstructor">forward</a> <a id="10966" href="/Relations/#10966" class="Bound">m≤n</a>  <a id="10971" class="Symbol">=</a>  <a id="10974" href="/Relations/#9703" class="InductiveConstructor">forward</a> <a id="10982" class="Symbol">(</a><a id="10983" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="10987" href="/Relations/#10966" class="Bound">m≤n</a><a id="10990" class="Symbol">)</a>
<a id="10992" class="Symbol">...</a>                        <a id="11019" class="Symbol">|</a> <a id="11021" href="/Relations/#9733" class="InductiveConstructor">flipped</a> <a id="11029" href="/Relations/#11029" class="Bound">n≤m</a>  <a id="11034" class="Symbol">=</a>  <a id="11037" href="/Relations/#9733" class="InductiveConstructor">flipped</a> <a id="11045" class="Symbol">(</a><a id="11046" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="11050" href="/Relations/#11029" class="Bound">n≤m</a><a id="11053" class="Symbol">)</a></pre>
<p>In this case the proof is by induction over both the first
and second arguments.  We perform a case analysis:</p>

<ul>
  <li>
    <p><em>First base case</em>: If the first argument is <code class="highlighter-rouge">zero</code> and the
second argument is <code class="highlighter-rouge">n</code> then the forward case holds,
with <code class="highlighter-rouge">z≤n</code> as evidence that <code class="highlighter-rouge">zero ≤ n</code>.</p>
  </li>
  <li>
    <p><em>Second base case</em>: If the first argument is <code class="highlighter-rouge">suc m</code> and the
second argument is <code class="highlighter-rouge">zero</code> then the flipped case holds, with
<code class="highlighter-rouge">z≤n</code> as evidence that <code class="highlighter-rouge">zero ≤ suc m</code>.</p>
  </li>
  <li>
    <p><em>Inductive case</em>: If the first argument is <code class="highlighter-rouge">suc m</code> and the
second argument is <code class="highlighter-rouge">suc n</code>, then the inductive hypothesis
<code class="highlighter-rouge">≤-total m n</code> establishes one of the following:</p>

    <ul>
      <li>
        <p>The forward case of the inductive hypothesis holds with <code class="highlighter-rouge">m≤n</code> as
evidence that <code class="highlighter-rouge">m ≤ n</code>, from which it follows that the forward case of the
proposition holds with <code class="highlighter-rouge">s≤s m≤n</code> as evidence that <code class="highlighter-rouge">suc m ≤ suc n</code>.</p>
      </li>
      <li>
        <p>The flipped case of the inductive hypothesis holds with <code class="highlighter-rouge">n≤m</code> as
evidence that <code class="highlighter-rouge">n ≤ m</code>, from which it follows that the flipped case of the
proposition holds with <code class="highlighter-rouge">s≤s n≤m</code> as evidence that <code class="highlighter-rouge">suc n ≤ suc m</code>.</p>
      </li>
    </ul>
  </li>
</ul>

<p>This is our first use of the <code class="highlighter-rouge">with</code> clause in Agda.  The keyword
<code class="highlighter-rouge">with</code> is followed by an expression and one or more subsequent lines.
Each line begins with an ellipsis (<code class="highlighter-rouge">...</code>) and a vertical bar (<code class="highlighter-rouge">|</code>),
followed by a pattern to be matched against the expression
and the right-hand side of the equation.</p>

<p>Every use of <code class="highlighter-rouge">with</code> is equivalent to defining a helper function.  For
example, the definition above is equivalent to the following.</p>
<pre class="Agda"><a id="≤-total′"></a><a id="12561" href="/Relations/#12561" class="Function">≤-total′</a> <a id="12570" class="Symbol">:</a> <a id="12572" class="Symbol">∀</a> <a id="12574" class="Symbol">(</a><a id="12575" href="/Relations/#12575" class="Bound">m</a> <a id="12577" href="/Relations/#12577" class="Bound">n</a> <a id="12579" class="Symbol">:</a> <a id="12581" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="12582" class="Symbol">)</a> <a id="12584" class="Symbol">→</a> <a id="12586" href="/Relations/#9673" class="Datatype">Total</a> <a id="12592" href="/Relations/#12575" class="Bound">m</a> <a id="12594" href="/Relations/#12577" class="Bound">n</a>
<a id="12596" href="/Relations/#12561" class="Function">≤-total′</a> <a id="12605" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a>    <a id="12613" href="/Relations/#12613" class="Bound">n</a>        <a id="12622" class="Symbol">=</a>  <a id="12625" href="/Relations/#9703" class="InductiveConstructor">forward</a> <a id="12633" href="/Relations/#1231" class="InductiveConstructor">z≤n</a>
<a id="12637" href="/Relations/#12561" class="Function">≤-total′</a> <a id="12646" class="Symbol">(</a><a id="12647" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="12651" href="/Relations/#12651" class="Bound">m</a><a id="12652" class="Symbol">)</a> <a id="12654" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a>     <a id="12663" class="Symbol">=</a>  <a id="12666" href="/Relations/#9733" class="InductiveConstructor">flipped</a> <a id="12674" href="/Relations/#1231" class="InductiveConstructor">z≤n</a>
<a id="12678" href="/Relations/#12561" class="Function">≤-total′</a> <a id="12687" class="Symbol">(</a><a id="12688" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="12692" href="/Relations/#12692" class="Bound">m</a><a id="12693" class="Symbol">)</a> <a id="12695" class="Symbol">(</a><a id="12696" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="12700" href="/Relations/#12700" class="Bound">n</a><a id="12701" class="Symbol">)</a>  <a id="12704" class="Symbol">=</a>  <a id="12707" href="/Relations/#12739" class="Function">helper</a> <a id="12714" class="Symbol">(</a><a id="12715" href="/Relations/#12561" class="Function">≤-total′</a> <a id="12724" href="/Relations/#12692" class="Bound">m</a> <a id="12726" href="/Relations/#12700" class="Bound">n</a><a id="12727" class="Symbol">)</a>
  <a id="12731" class="Keyword">where</a>
  <a id="12739" href="/Relations/#12739" class="Function">helper</a> <a id="12746" class="Symbol">:</a> <a id="12748" href="/Relations/#9673" class="Datatype">Total</a> <a id="12754" href="/Relations/#12692" class="Bound">m</a> <a id="12756" href="/Relations/#12700" class="Bound">n</a> <a id="12758" class="Symbol">→</a> <a id="12760" href="/Relations/#9673" class="Datatype">Total</a> <a id="12766" class="Symbol">(</a><a id="12767" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="12771" href="/Relations/#12692" class="Bound">m</a><a id="12772" class="Symbol">)</a> <a id="12774" class="Symbol">(</a><a id="12775" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="12779" href="/Relations/#12700" class="Bound">n</a><a id="12780" class="Symbol">)</a>
  <a id="12784" href="/Relations/#12739" class="Function">helper</a> <a id="12791" class="Symbol">(</a><a id="12792" href="/Relations/#9703" class="InductiveConstructor">forward</a> <a id="12800" href="/Relations/#12800" class="Bound">m≤n</a><a id="12803" class="Symbol">)</a>  <a id="12806" class="Symbol">=</a>  <a id="12809" href="/Relations/#9703" class="InductiveConstructor">forward</a> <a id="12817" class="Symbol">(</a><a id="12818" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="12822" href="/Relations/#12800" class="Bound">m≤n</a><a id="12825" class="Symbol">)</a>
  <a id="12829" href="/Relations/#12739" class="Function">helper</a> <a id="12836" class="Symbol">(</a><a id="12837" href="/Relations/#9733" class="InductiveConstructor">flipped</a> <a id="12845" href="/Relations/#12845" class="Bound">n≤m</a><a id="12848" class="Symbol">)</a>  <a id="12851" class="Symbol">=</a>  <a id="12854" href="/Relations/#9733" class="InductiveConstructor">flipped</a> <a id="12862" class="Symbol">(</a><a id="12863" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="12867" href="/Relations/#12845" class="Bound">n≤m</a><a id="12870" class="Symbol">)</a></pre>
<p>This is also our first use of a <code class="highlighter-rouge">where</code> clause in Agda.  The keyword <code class="highlighter-rouge">where</code> is
followed by one or more definitions, which must be indented.  Any variables
bound of the left-hand side of the preceding equation (in this case, <code class="highlighter-rouge">m</code> and
<code class="highlighter-rouge">n</code>) are in scope within the nested definition, and any identifiers bound in the
nested definition (in this case, <code class="highlighter-rouge">helper</code>) are in scope in the right-hand side
of the preceding equation.</p>

<p>If both arguments are equal, then both cases hold and we could return evidence
of either.  In the code above we return the forward case, but there is a
variant that returns the flipped case.</p>
<pre class="Agda"><a id="≤-total″"></a><a id="13508" href="/Relations/#13508" class="Function">≤-total″</a> <a id="13517" class="Symbol">:</a> <a id="13519" class="Symbol">∀</a> <a id="13521" class="Symbol">(</a><a id="13522" href="/Relations/#13522" class="Bound">m</a> <a id="13524" href="/Relations/#13524" class="Bound">n</a> <a id="13526" class="Symbol">:</a> <a id="13528" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="13529" class="Symbol">)</a> <a id="13531" class="Symbol">→</a> <a id="13533" href="/Relations/#9673" class="Datatype">Total</a> <a id="13539" href="/Relations/#13522" class="Bound">m</a> <a id="13541" href="/Relations/#13524" class="Bound">n</a>
<a id="13543" href="/Relations/#13508" class="Function">≤-total″</a> <a id="13552" href="/Relations/#13552" class="Bound">m</a>       <a id="13560" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a>                      <a id="13586" class="Symbol">=</a>  <a id="13589" href="/Relations/#9733" class="InductiveConstructor">flipped</a> <a id="13597" href="/Relations/#1231" class="InductiveConstructor">z≤n</a>
<a id="13601" href="/Relations/#13508" class="Function">≤-total″</a> <a id="13610" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a>    <a id="13618" class="Symbol">(</a><a id="13619" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="13623" href="/Relations/#13623" class="Bound">n</a><a id="13624" class="Symbol">)</a>                   <a id="13644" class="Symbol">=</a>  <a id="13647" href="/Relations/#9703" class="InductiveConstructor">forward</a> <a id="13655" href="/Relations/#1231" class="InductiveConstructor">z≤n</a>
<a id="13659" href="/Relations/#13508" class="Function">≤-total″</a> <a id="13668" class="Symbol">(</a><a id="13669" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="13673" href="/Relations/#13673" class="Bound">m</a><a id="13674" class="Symbol">)</a> <a id="13676" class="Symbol">(</a><a id="13677" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="13681" href="/Relations/#13681" class="Bound">n</a><a id="13682" class="Symbol">)</a> <a id="13684" class="Keyword">with</a> <a id="13689" href="/Relations/#13508" class="Function">≤-total″</a> <a id="13698" href="/Relations/#13673" class="Bound">m</a> <a id="13700" href="/Relations/#13681" class="Bound">n</a>
<a id="13702" class="Symbol">...</a>                        <a id="13729" class="Symbol">|</a> <a id="13731" href="/Relations/#9703" class="InductiveConstructor">forward</a> <a id="13739" href="/Relations/#13739" class="Bound">m≤n</a>   <a id="13745" class="Symbol">=</a>  <a id="13748" href="/Relations/#9703" class="InductiveConstructor">forward</a> <a id="13756" class="Symbol">(</a><a id="13757" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="13761" href="/Relations/#13739" class="Bound">m≤n</a><a id="13764" class="Symbol">)</a>
<a id="13766" class="Symbol">...</a>                        <a id="13793" class="Symbol">|</a> <a id="13795" href="/Relations/#9733" class="InductiveConstructor">flipped</a> <a id="13803" href="/Relations/#13803" class="Bound">n≤m</a>   <a id="13809" class="Symbol">=</a>  <a id="13812" href="/Relations/#9733" class="InductiveConstructor">flipped</a> <a id="13820" class="Symbol">(</a><a id="13821" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="13825" href="/Relations/#13803" class="Bound">n≤m</a><a id="13828" class="Symbol">)</a></pre>
<p>It differs from the original code in that it pattern
matches on the second argument before the first argument.</p>

<h2 id="monotonicity">Monotonicity</h2>

<p>If one bumps into both an operator and an ordering at a party, one may ask if
the operator is <em>monotonic</em> with regard to the ordering.  For example, addition
is monotonic with regard to inequality, meaning</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>∀ {m n p q : ℕ} → m ≤ n → p ≤ q → m + p ≤ n + q
</code></pre></div></div>

<p>The proof is straightforward using the techniques we have learned, and is best
broken into three parts. First, we deal with the special case of showing
addition is monotonic on the right.</p>
<pre class="Agda"><a id="+-monoʳ-≤"></a><a id="14432" href="/Relations/#14432" class="Function">+-monoʳ-≤</a> <a id="14442" class="Symbol">:</a> <a id="14444" class="Symbol">∀</a> <a id="14446" class="Symbol">(</a><a id="14447" href="/Relations/#14447" class="Bound">m</a> <a id="14449" href="/Relations/#14449" class="Bound">p</a> <a id="14451" href="/Relations/#14451" class="Bound">q</a> <a id="14453" class="Symbol">:</a> <a id="14455" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="14456" class="Symbol">)</a> <a id="14458" class="Symbol">→</a> <a id="14460" href="/Relations/#14449" class="Bound">p</a> <a id="14462" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="14464" href="/Relations/#14451" class="Bound">q</a> <a id="14466" class="Symbol">→</a> <a id="14468" href="/Relations/#14447" class="Bound">m</a> <a id="14470" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="14472" href="/Relations/#14449" class="Bound">p</a> <a id="14474" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="14476" href="/Relations/#14447" class="Bound">m</a> <a id="14478" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="14480" href="/Relations/#14451" class="Bound">q</a>
<a id="14482" href="/Relations/#14432" class="Function">+-monoʳ-≤</a> <a id="14492" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a>    <a id="14500" href="/Relations/#14500" class="Bound">p</a> <a id="14502" href="/Relations/#14502" class="Bound">q</a> <a id="14504" href="/Relations/#14504" class="Bound">p≤q</a>  <a id="14509" class="Symbol">=</a>  <a id="14512" href="/Relations/#14504" class="Bound">p≤q</a>
<a id="14516" href="/Relations/#14432" class="Function">+-monoʳ-≤</a> <a id="14526" class="Symbol">(</a><a id="14527" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="14531" href="/Relations/#14531" class="Bound">m</a><a id="14532" class="Symbol">)</a> <a id="14534" href="/Relations/#14534" class="Bound">p</a> <a id="14536" href="/Relations/#14536" class="Bound">q</a> <a id="14538" href="/Relations/#14538" class="Bound">p≤q</a>  <a id="14543" class="Symbol">=</a>  <a id="14546" href="/Relations/#1260" class="InductiveConstructor">s≤s</a> <a id="14550" class="Symbol">(</a><a id="14551" href="/Relations/#14432" class="Function">+-monoʳ-≤</a> <a id="14561" href="/Relations/#14531" class="Bound">m</a> <a id="14563" href="/Relations/#14534" class="Bound">p</a> <a id="14565" href="/Relations/#14536" class="Bound">q</a> <a id="14567" href="/Relations/#14538" class="Bound">p≤q</a><a id="14570" class="Symbol">)</a></pre>
<p>The proof is by induction on the first argument.</p>

<ul>
  <li>
    <p><em>Base case</em>: The first argument is <code class="highlighter-rouge">zero</code> in which case
<code class="highlighter-rouge">zero + p ≤ zero + q</code> simplifies to <code class="highlighter-rouge">p ≤ q</code>, the evidence
for which is given by the argument <code class="highlighter-rouge">p≤q</code>.</p>
  </li>
  <li>
    <p><em>Inductive case</em>: The first argument is <code class="highlighter-rouge">suc m</code>, in which case
<code class="highlighter-rouge">suc m + p ≤ suc m + q</code> simplifies to <code class="highlighter-rouge">suc (m + p) ≤ suc (m + q)</code>.
The inductive hypothesis <code class="highlighter-rouge">+-monoʳ-≤ m p q p≤q</code> establishes that
<code class="highlighter-rouge">m + p ≤ m + q</code>, and our goal follows by applying <code class="highlighter-rouge">s≤s</code>.</p>
  </li>
</ul>

<p>Second, we deal with the special case of showing addition is
monotonic on the left. This follows from the previous
result and the commutativity of addition.</p>
<pre class="Agda"><a id="+-monoˡ-≤"></a><a id="15226" href="/Relations/#15226" class="Function">+-monoˡ-≤</a> <a id="15236" class="Symbol">:</a> <a id="15238" class="Symbol">∀</a> <a id="15240" class="Symbol">(</a><a id="15241" href="/Relations/#15241" class="Bound">m</a> <a id="15243" href="/Relations/#15243" class="Bound">n</a> <a id="15245" href="/Relations/#15245" class="Bound">p</a> <a id="15247" class="Symbol">:</a> <a id="15249" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="15250" class="Symbol">)</a> <a id="15252" class="Symbol">→</a> <a id="15254" href="/Relations/#15241" class="Bound">m</a> <a id="15256" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="15258" href="/Relations/#15243" class="Bound">n</a> <a id="15260" class="Symbol">→</a> <a id="15262" href="/Relations/#15241" class="Bound">m</a> <a id="15264" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="15266" href="/Relations/#15245" class="Bound">p</a> <a id="15268" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="15270" href="/Relations/#15243" class="Bound">n</a> <a id="15272" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="15274" href="/Relations/#15245" class="Bound">p</a>
<a id="15276" href="/Relations/#15226" class="Function">+-monoˡ-≤</a> <a id="15286" href="/Relations/#15286" class="Bound">m</a> <a id="15288" href="/Relations/#15288" class="Bound">n</a> <a id="15290" href="/Relations/#15290" class="Bound">p</a> <a id="15292" href="/Relations/#15292" class="Bound">m≤n</a> <a id="15296" class="Keyword">rewrite</a> <a id="15304" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#8115" class="Function">+-comm</a> <a id="15311" href="/Relations/#15286" class="Bound">m</a> <a id="15313" href="/Relations/#15290" class="Bound">p</a> <a id="15315" class="Symbol">|</a> <a id="15317" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#8115" class="Function">+-comm</a> <a id="15324" href="/Relations/#15288" class="Bound">n</a> <a id="15326" href="/Relations/#15290" class="Bound">p</a> <a id="15328" class="Symbol">=</a> <a id="15330" href="/Relations/#14432" class="Function">+-monoʳ-≤</a> <a id="15340" href="/Relations/#15290" class="Bound">p</a> <a id="15342" href="/Relations/#15286" class="Bound">m</a> <a id="15344" href="/Relations/#15288" class="Bound">n</a> <a id="15346" href="/Relations/#15292" class="Bound">m≤n</a></pre>
<p>Rewriting by <code class="highlighter-rouge">+-comm m p</code> and <code class="highlighter-rouge">+-comm n p</code> converts <code class="highlighter-rouge">m + p ≤ n + p</code> into
<code class="highlighter-rouge">p + m ≤ p + n</code>, which is proved by invoking <code class="highlighter-rouge">+-monoʳ-≤ p m n m≤n</code>.</p>

<p>Third, we combine the two previous results.</p>
<pre class="Agda"><a id="+-mono-≤"></a><a id="15560" href="/Relations/#15560" class="Function">+-mono-≤</a> <a id="15569" class="Symbol">:</a> <a id="15571" class="Symbol">∀</a> <a id="15573" class="Symbol">(</a><a id="15574" href="/Relations/#15574" class="Bound">m</a> <a id="15576" href="/Relations/#15576" class="Bound">n</a> <a id="15578" href="/Relations/#15578" class="Bound">p</a> <a id="15580" href="/Relations/#15580" class="Bound">q</a> <a id="15582" class="Symbol">:</a> <a id="15584" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="15585" class="Symbol">)</a> <a id="15587" class="Symbol">→</a> <a id="15589" href="/Relations/#15574" class="Bound">m</a> <a id="15591" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="15593" href="/Relations/#15576" class="Bound">n</a> <a id="15595" class="Symbol">→</a> <a id="15597" href="/Relations/#15578" class="Bound">p</a> <a id="15599" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="15601" href="/Relations/#15580" class="Bound">q</a> <a id="15603" class="Symbol">→</a> <a id="15605" href="/Relations/#15574" class="Bound">m</a> <a id="15607" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="15609" href="/Relations/#15578" class="Bound">p</a> <a id="15611" href="/Relations/#1205" class="Datatype Operator">≤</a> <a id="15613" href="/Relations/#15576" class="Bound">n</a> <a id="15615" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="15617" href="/Relations/#15580" class="Bound">q</a>
<a id="15619" href="/Relations/#15560" class="Function">+-mono-≤</a> <a id="15628" href="/Relations/#15628" class="Bound">m</a> <a id="15630" href="/Relations/#15630" class="Bound">n</a> <a id="15632" href="/Relations/#15632" class="Bound">p</a> <a id="15634" href="/Relations/#15634" class="Bound">q</a> <a id="15636" href="/Relations/#15636" class="Bound">m≤n</a> <a id="15640" href="/Relations/#15640" class="Bound">p≤q</a> <a id="15644" class="Symbol">=</a> <a id="15646" href="/Relations/#6368" class="Function">≤-trans</a> <a id="15654" class="Symbol">(</a><a id="15655" href="/Relations/#15226" class="Function">+-monoˡ-≤</a> <a id="15665" href="/Relations/#15628" class="Bound">m</a> <a id="15667" href="/Relations/#15630" class="Bound">n</a> <a id="15669" href="/Relations/#15632" class="Bound">p</a> <a id="15671" href="/Relations/#15636" class="Bound">m≤n</a><a id="15674" class="Symbol">)</a> <a id="15676" class="Symbol">(</a><a id="15677" href="/Relations/#14432" class="Function">+-monoʳ-≤</a> <a id="15687" href="/Relations/#15630" class="Bound">n</a> <a id="15689" href="/Relations/#15632" class="Bound">p</a> <a id="15691" href="/Relations/#15634" class="Bound">q</a> <a id="15693" href="/Relations/#15640" class="Bound">p≤q</a><a id="15696" class="Symbol">)</a></pre>
<p>Invoking <code class="highlighter-rouge">+-monoˡ-≤ m n p m≤n</code> proves <code class="highlighter-rouge">m + p ≤ n + p</code> and invoking
<code class="highlighter-rouge">+-monoʳ-≤ n p q p≤q</code> proves <code class="highlighter-rouge">n + p ≤ n + q</code>, and combining these with
transitivity proves <code class="highlighter-rouge">m + p ≤ n + q</code>, as was to be shown.</p>

<h3 id="exercise-stretch--reasoning">Exercise (stretch, <code class="highlighter-rouge">≤-reasoning</code>)</h3>

<p>The proof of monotonicity (and the associated lemmas) can be written
in a more readable form by using an anologue of our notation for
<code class="highlighter-rouge">≡-reasoning</code>.  Read ahead to chapter <a href="/Equality/">Equality</a> to
see how <code class="highlighter-rouge">≡-reasoning</code> is defined, define <code class="highlighter-rouge">≤-reasoning</code> analogously,
and use it to write out an alternative proof that addition is
monotonic with regard to inequality.</p>

<h2 id="strict-inequality">Strict inequality</h2>

<p>We can define strict inequality similarly to inequality.</p>
<pre class="Agda"><a id="16463" class="Keyword">infix</a> <a id="16469" class="Number">4</a> <a id="16471" href="/Relations/#16481" class="Datatype Operator">_&lt;_</a>

<a id="16476" class="Keyword">data</a> <a id="_&lt;_"></a><a id="16481" href="/Relations/#16481" class="Datatype Operator">_&lt;_</a> <a id="16485" class="Symbol">:</a> <a id="16487" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a> <a id="16489" class="Symbol">→</a> <a id="16491" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a> <a id="16493" class="Symbol">→</a> <a id="16495" class="PrimitiveType">Set</a> <a id="16499" class="Keyword">where</a>
  <a id="_&lt;_.z&lt;s"></a><a id="16507" href="/Relations/#16507" class="InductiveConstructor">z&lt;s</a> <a id="16511" class="Symbol">:</a> <a id="16513" class="Symbol">∀</a> <a id="16515" class="Symbol">{</a><a id="16516" href="/Relations/#16516" class="Bound">n</a> <a id="16518" class="Symbol">:</a> <a id="16520" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="16521" class="Symbol">}</a> <a id="16523" class="Symbol">→</a> <a id="16525" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a> <a id="16530" href="/Relations/#16481" class="Datatype Operator">&lt;</a> <a id="16532" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="16536" href="/Relations/#16516" class="Bound">n</a>
  <a id="_&lt;_.s&lt;s"></a><a id="16540" href="/Relations/#16540" class="InductiveConstructor">s&lt;s</a> <a id="16544" class="Symbol">:</a> <a id="16546" class="Symbol">∀</a> <a id="16548" class="Symbol">{</a><a id="16549" href="/Relations/#16549" class="Bound">m</a> <a id="16551" href="/Relations/#16551" class="Bound">n</a> <a id="16553" class="Symbol">:</a> <a id="16555" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="16556" class="Symbol">}</a> <a id="16558" class="Symbol">→</a> <a id="16560" href="/Relations/#16549" class="Bound">m</a> <a id="16562" href="/Relations/#16481" class="Datatype Operator">&lt;</a> <a id="16564" href="/Relations/#16551" class="Bound">n</a> <a id="16566" class="Symbol">→</a> <a id="16568" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="16572" href="/Relations/#16549" class="Bound">m</a> <a id="16574" href="/Relations/#16481" class="Datatype Operator">&lt;</a> <a id="16576" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="16580" href="/Relations/#16551" class="Bound">n</a></pre>
<p>The key difference is that zero is less than the successor of an
arbitrary number, but is not less than zero.</p>

<p>Clearly, strict inequality is not reflexive. However it is
<em>irreflexive</em> in that <code class="highlighter-rouge">n &lt; n</code> never holds for any value of <code class="highlighter-rouge">n</code>.
Like inequality, strict inequality is transitive.
Strict inequality is not total, but satisfies the closely related property of
<em>trichotomy</em>: for any <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">n</code>, exactly one of <code class="highlighter-rouge">m &lt; n</code>, <code class="highlighter-rouge">m ≡ n</code>, or <code class="highlighter-rouge">m &gt; n</code>
holds (where we define <code class="highlighter-rouge">m &gt; n</code> to hold exactly where <code class="highlighter-rouge">n &lt; m</code>).
It is also monotonic with regards to addition and multiplication.</p>

<p>Most of the above are considered in exercises below.  Irreflexivity
requires negation, as does the fact that the three cases in
trichotomy are mutually exclusive, so those points are deferred
to the chapter that introduces <a href="/Negation/">negation</a>.</p>

<p>It is straightforward to show that <code class="highlighter-rouge">suc m ≤ n</code> implies <code class="highlighter-rouge">m &lt; n</code>,
and conversely.  One can then give an alternative derivation of the
properties of strict inequality, such as transitivity, by directly
exploiting the corresponding properties of inequality.</p>

<h3 id="exercise--trans">Exercise (<code class="highlighter-rouge">&lt;-trans</code>)</h3>

<p>Show that strict inequality is transitive.</p>

<h3 id="trichotomy">Exercise (<code class="highlighter-rouge">trichotomy</code>)</h3>

<p>Show that strict inequality satisfies a weak version of trichotomy, in
the sense that for any <code class="highlighter-rouge">m</code> and <code class="highlighter-rouge">n</code> that one of the following holds:</p>
<ul>
  <li><code class="highlighter-rouge">m &lt; n</code>,</li>
  <li><code class="highlighter-rouge">m ≡ n</code>, or</li>
  <li><code class="highlighter-rouge">m &gt; n</code>
This only involves two relations, as we define <code class="highlighter-rouge">m &gt; n</code> to
be the same as <code class="highlighter-rouge">n &lt; m</code>. You will need a suitable data declaration,
similar to that used for totality.  (We will show that the three cases
are exclusive after <a href="/Negation/">negation</a> is introduced.)</li>
</ul>

<h3 id="exercise--mono-">Exercise (<code class="highlighter-rouge">+-mono-&lt;</code>)</h3>

<p>Show that addition is monotonic with respect to strict inequality.
As with inequality, some additional definitions may be required.</p>

<h3 id="exercise--implies---implies-">Exercise (<code class="highlighter-rouge">≤-implies-&lt;</code>, <code class="highlighter-rouge">&lt;-implies-≤</code>)</h3>

<p>Show that <code class="highlighter-rouge">suc m ≤ n</code> implies <code class="highlighter-rouge">m &lt; n</code>, and conversely.</p>

<h3 id="exercise--trans-1">Exercise (<code class="highlighter-rouge">&lt;-trans′</code>)</h3>

<p>Give an alternative proof that strict inequality is transitive,
using the relating between strict inequality and inequality and
the fact that inequality is transitive.</p>

<h2 id="even-and-odd">Even and odd</h2>

<p>As a further example, let’s specify even and odd numbers.  Inequality
and strict inequality are <em>binary relations</em>, while even and odd are
<em>unary relations</em>, sometimes called <em>predicates</em>.</p>
<pre class="Agda"><a id="18965" class="Keyword">data</a> <a id="even"></a><a id="18970" href="/Relations/#18970" class="Datatype">even</a> <a id="18975" class="Symbol">:</a> <a id="18977" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a> <a id="18979" class="Symbol">→</a> <a id="18981" class="PrimitiveType">Set</a>
<a id="18985" class="Keyword">data</a> <a id="odd"></a><a id="18990" href="/Relations/#18990" class="Datatype">odd</a>  <a id="18995" class="Symbol">:</a> <a id="18997" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a> <a id="18999" class="Symbol">→</a> <a id="19001" class="PrimitiveType">Set</a>

<a id="19006" class="Keyword">data</a> <a id="19011" href="/Relations/#18970" class="Datatype">even</a> <a id="19016" class="Keyword">where</a>
  <a id="even.zero"></a><a id="19024" href="/Relations/#19024" class="InductiveConstructor">zero</a> <a id="19029" class="Symbol">:</a> <a id="19031" href="/Relations/#18970" class="Datatype">even</a> <a id="19036" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a>
  <a id="even.suc"></a><a id="19043" href="/Relations/#19043" class="InductiveConstructor">suc</a>  <a id="19048" class="Symbol">:</a> <a id="19050" class="Symbol">∀</a> <a id="19052" class="Symbol">{</a><a id="19053" href="/Relations/#19053" class="Bound">n</a> <a id="19055" class="Symbol">:</a> <a id="19057" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="19058" class="Symbol">}</a> <a id="19060" class="Symbol">→</a> <a id="19062" href="/Relations/#18990" class="Datatype">odd</a> <a id="19066" href="/Relations/#19053" class="Bound">n</a> <a id="19068" class="Symbol">→</a> <a id="19070" href="/Relations/#18970" class="Datatype">even</a> <a id="19075" class="Symbol">(</a><a id="19076" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="19080" href="/Relations/#19053" class="Bound">n</a><a id="19081" class="Symbol">)</a>

<a id="19084" class="Keyword">data</a> <a id="19089" href="/Relations/#18990" class="Datatype">odd</a> <a id="19093" class="Keyword">where</a>
  <a id="odd.suc"></a><a id="19101" href="/Relations/#19101" class="InductiveConstructor">suc</a>   <a id="19107" class="Symbol">:</a> <a id="19109" class="Symbol">∀</a> <a id="19111" class="Symbol">{</a><a id="19112" href="/Relations/#19112" class="Bound">n</a> <a id="19114" class="Symbol">:</a> <a id="19116" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="19117" class="Symbol">}</a> <a id="19119" class="Symbol">→</a> <a id="19121" href="/Relations/#18970" class="Datatype">even</a> <a id="19126" href="/Relations/#19112" class="Bound">n</a> <a id="19128" class="Symbol">→</a> <a id="19130" href="/Relations/#18990" class="Datatype">odd</a> <a id="19134" class="Symbol">(</a><a id="19135" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a> <a id="19139" href="/Relations/#19112" class="Bound">n</a><a id="19140" class="Symbol">)</a></pre>
<p>A number is even if it is zero or the successor of an odd number,
and odd if it is the successor of an even number.</p>

<p>This is our first use of a mutually recursive datatype declaration.
Since each identifier must be defined before it is used, we first
declare the indexed types <code class="highlighter-rouge">even</code> and <code class="highlighter-rouge">odd</code> (omitting the <code class="highlighter-rouge">where</code>
keyword and the declarations of the constructors) and then
declare the constructors (omitting the signatures <code class="highlighter-rouge">ℕ → Set</code>
which were given earlier).</p>

<p>This is also our first use of <em>overloaded</em> constructors,
that is, using the same name for different constructors depending on
the context.  Here <code class="highlighter-rouge">suc</code> means one of three constructors:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>suc : `ℕ → `ℕ
suc : ∀ {n : ℕ} → odd n → even (suc n)
suc : ∀ {n : ℕ} → even n → odd (suc n)
</code></pre></div></div>

<p>Similarly, <code class="highlighter-rouge">zero</code> refers to one of two constructors. Due to how it
does type inference, Agda does not allow overloading of defined names,
but does allow overloading of constructors.  It is recommended that
one restrict overloading to related meanings, as we have done here,
but it is not required.</p>

<p>We show that the sum of two even numbers is even.</p>
<pre class="Agda"><a id="e+e≡e"></a><a id="20268" href="/Relations/#20268" class="Function">e+e≡e</a> <a id="20274" class="Symbol">:</a> <a id="20276" class="Symbol">∀</a> <a id="20278" class="Symbol">{</a><a id="20279" href="/Relations/#20279" class="Bound">m</a> <a id="20281" href="/Relations/#20281" class="Bound">n</a> <a id="20283" class="Symbol">:</a> <a id="20285" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="20286" class="Symbol">}</a> <a id="20288" class="Symbol">→</a> <a id="20290" href="/Relations/#18970" class="Datatype">even</a> <a id="20295" href="/Relations/#20279" class="Bound">m</a> <a id="20297" class="Symbol">→</a> <a id="20299" href="/Relations/#18970" class="Datatype">even</a> <a id="20304" href="/Relations/#20281" class="Bound">n</a> <a id="20306" class="Symbol">→</a> <a id="20308" href="/Relations/#18970" class="Datatype">even</a> <a id="20313" class="Symbol">(</a><a id="20314" href="/Relations/#20279" class="Bound">m</a> <a id="20316" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="20318" href="/Relations/#20281" class="Bound">n</a><a id="20319" class="Symbol">)</a>
<a id="o+e≡o"></a><a id="20321" href="/Relations/#20321" class="Function">o+e≡o</a> <a id="20327" class="Symbol">:</a> <a id="20329" class="Symbol">∀</a> <a id="20331" class="Symbol">{</a><a id="20332" href="/Relations/#20332" class="Bound">m</a> <a id="20334" href="/Relations/#20334" class="Bound">n</a> <a id="20336" class="Symbol">:</a> <a id="20338" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="20339" class="Symbol">}</a> <a id="20341" class="Symbol">→</a> <a id="20343" href="/Relations/#18990" class="Datatype">odd</a>  <a id="20348" href="/Relations/#20332" class="Bound">m</a> <a id="20350" class="Symbol">→</a> <a id="20352" href="/Relations/#18970" class="Datatype">even</a> <a id="20357" href="/Relations/#20334" class="Bound">n</a> <a id="20359" class="Symbol">→</a> <a id="20361" href="/Relations/#18990" class="Datatype">odd</a>  <a id="20366" class="Symbol">(</a><a id="20367" href="/Relations/#20332" class="Bound">m</a> <a id="20369" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">+</a> <a id="20371" href="/Relations/#20334" class="Bound">n</a><a id="20372" class="Symbol">)</a>

<a id="20375" href="/Relations/#20268" class="Function">e+e≡e</a> <a id="20381" href="/Relations/#19024" class="InductiveConstructor">zero</a>     <a id="20390" href="/Relations/#20390" class="Bound">en</a>  <a id="20394" class="Symbol">=</a>  <a id="20397" href="/Relations/#20390" class="Bound">en</a>
<a id="20400" href="/Relations/#20268" class="Function">e+e≡e</a> <a id="20406" class="Symbol">(</a><a id="20407" href="/Relations/#19043" class="InductiveConstructor">suc</a> <a id="20411" href="/Relations/#20411" class="Bound">om</a><a id="20413" class="Symbol">)</a> <a id="20415" href="/Relations/#20415" class="Bound">en</a>  <a id="20419" class="Symbol">=</a>  <a id="20422" href="/Relations/#19043" class="InductiveConstructor">suc</a> <a id="20426" class="Symbol">(</a><a id="20427" href="/Relations/#20321" class="Function">o+e≡o</a> <a id="20433" href="/Relations/#20411" class="Bound">om</a> <a id="20436" href="/Relations/#20415" class="Bound">en</a><a id="20438" class="Symbol">)</a>

<a id="20441" href="/Relations/#20321" class="Function">o+e≡o</a> <a id="20447" class="Symbol">(</a><a id="20448" href="/Relations/#19101" class="InductiveConstructor">suc</a> <a id="20452" href="/Relations/#20452" class="Bound">em</a><a id="20454" class="Symbol">)</a> <a id="20456" href="/Relations/#20456" class="Bound">en</a>  <a id="20460" class="Symbol">=</a>  <a id="20463" href="/Relations/#19101" class="InductiveConstructor">suc</a> <a id="20467" class="Symbol">(</a><a id="20468" href="/Relations/#20268" class="Function">e+e≡e</a> <a id="20474" href="/Relations/#20452" class="Bound">em</a> <a id="20477" href="/Relations/#20456" class="Bound">en</a><a id="20479" class="Symbol">)</a></pre>
<p>Corresponding to the mutually recursive types, we use two mutually recursive
functions, one to show that the sum of two even numbers is even, and the other
to show that the sum of an odd and an even number is odd.</p>

<p>This is our first use of mutually recursive functions.  Since each identifier
must be defined before it is used, we first give the signatures for both
functions and then the equations that define them.</p>

<p>To show that the sum of two even numbers is even, consider the evidence that the
first number is even. If it is because it is zero, then the sum is even because the
second number is even.  If it is because it is the successor of an odd number,
then the result is even because it is the successor of the sum of an odd and an
even number, which is odd.</p>

<p>To show that the sum of an odd and even number is odd, consider the evidence
that the first number is odd. If it is because it is the successor of an even
number, then the result is odd because it is the successor of the sum of two
even numbers, which is even.</p>

<h3 id="exercise-ooe">Exercise (<code class="highlighter-rouge">o+o≡e</code>)</h3>

<p>Show that the sum of two odd numbers is even.</p>

<!--

## Formalising preorder

<pre class="Agda"><a id="21640" class="Keyword">record</a> <a id="IsPreorder"></a><a id="21647" href="/Relations/#21647" class="Record">IsPreorder</a> <a id="21658" class="Symbol">{</a><a id="21659" href="/Relations/#21659" class="Bound">A</a> <a id="21661" class="Symbol">:</a> <a id="21663" class="PrimitiveType">Set</a><a id="21666" class="Symbol">}</a> <a id="21668" class="Symbol">(</a><a id="21669" href="/Relations/#21669" class="Bound Operator">_≤_</a> <a id="21673" class="Symbol">:</a> <a id="21675" href="/Relations/#21659" class="Bound">A</a> <a id="21677" class="Symbol">→</a> <a id="21679" href="/Relations/#21659" class="Bound">A</a> <a id="21681" class="Symbol">→</a> <a id="21683" class="PrimitiveType">Set</a><a id="21686" class="Symbol">)</a> <a id="21688" class="Symbol">:</a> <a id="21690" class="PrimitiveType">Set</a> <a id="21694" class="Keyword">where</a>
  <a id="21702" class="Keyword">field</a>
    <a id="IsPreorder.reflexive"></a><a id="21712" href="/Relations/#21712" class="Field">reflexive</a> <a id="21722" class="Symbol">:</a> <a id="21724" class="Symbol">∀</a> <a id="21726" class="Symbol">{</a><a id="21727" href="/Relations/#21727" class="Bound">x</a> <a id="21729" class="Symbol">:</a> <a id="21731" href="/Relations/#21659" class="Bound">A</a><a id="21732" class="Symbol">}</a> <a id="21734" class="Symbol">→</a> <a id="21736" href="/Relations/#21727" class="Bound">x</a> <a id="21738" href="/Relations/#21669" class="Bound Operator">≤</a> <a id="21740" href="/Relations/#21727" class="Bound">x</a>
    <a id="IsPreorder.trans"></a><a id="21746" href="/Relations/#21746" class="Field">trans</a> <a id="21752" class="Symbol">:</a> <a id="21754" class="Symbol">∀</a> <a id="21756" class="Symbol">{</a><a id="21757" href="/Relations/#21757" class="Bound">x</a> <a id="21759" href="/Relations/#21759" class="Bound">y</a> <a id="21761" href="/Relations/#21761" class="Bound">z</a> <a id="21763" class="Symbol">:</a> <a id="21765" href="/Relations/#21659" class="Bound">A</a><a id="21766" class="Symbol">}</a> <a id="21768" class="Symbol">→</a> <a id="21770" href="/Relations/#21757" class="Bound">x</a> <a id="21772" href="/Relations/#21669" class="Bound Operator">≤</a> <a id="21774" href="/Relations/#21759" class="Bound">y</a> <a id="21776" class="Symbol">→</a> <a id="21778" href="/Relations/#21759" class="Bound">y</a> <a id="21780" href="/Relations/#21669" class="Bound Operator">≤</a> <a id="21782" href="/Relations/#21761" class="Bound">z</a> <a id="21784" class="Symbol">→</a> <a id="21786" href="/Relations/#21757" class="Bound">x</a> <a id="21788" href="/Relations/#21669" class="Bound Operator">≤</a> <a id="21790" href="/Relations/#21761" class="Bound">z</a>

<a id="IsPreorder-≤"></a><a id="21793" href="/Relations/#21793" class="Function">IsPreorder-≤</a> <a id="21806" class="Symbol">:</a> <a id="21808" href="/Relations/#21647" class="Record">IsPreorder</a> <a id="21819" href="/Relations/#1205" class="Datatype Operator">_≤_</a>
<a id="21823" href="/Relations/#21793" class="Function">IsPreorder-≤</a> <a id="21836" class="Symbol">=</a>
  <a id="21840" class="Keyword">record</a>
    <a id="21851" class="Symbol">{</a> <a id="21853" class="Field">reflexive</a> <a id="21863" class="Symbol">=</a> <a id="21865" href="/Relations/#5710" class="Function">≤-refl</a>
    <a id="21876" class="Symbol">;</a> <a id="21878" class="Field">trans</a> <a id="21884" class="Symbol">=</a> <a id="21886" href="/Relations/#6368" class="Function">≤-trans</a>
    <a id="21898" class="Symbol">}</a></pre>

-->

<h2 id="standard-prelude">Standard prelude</h2>

<p>Definitions similar to those in this chapter can be found in the standard library.</p>
<pre class="Agda"><a id="22035" class="Keyword">import</a> <a id="22042" href="https://agda.github.io/agda-stdlib/Data.Nat.html" class="Module">Data.Nat</a> <a id="22051" class="Keyword">using</a> <a id="22057" class="Symbol">(</a><a id="22058" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#802" class="Datatype Operator">_≤_</a><a id="22061" class="Symbol">;</a> <a id="22063" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#833" class="InductiveConstructor">z≤n</a><a id="22066" class="Symbol">;</a> <a id="22068" href="https://agda.github.io/agda-stdlib/Data.Nat.Base.html#875" class="InductiveConstructor">s≤s</a><a id="22071" class="Symbol">)</a>
<a id="22073" class="Keyword">import</a> <a id="22080" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="22100" class="Keyword">using</a> <a id="22106" class="Symbol">(</a><a id="22107" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#1902" class="Function">≤-refl</a><a id="22113" class="Symbol">;</a> <a id="22115" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#2095" class="Function">≤-trans</a><a id="22122" class="Symbol">;</a> <a id="22124" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#1952" class="Function">≤-antisym</a><a id="22133" class="Symbol">;</a> <a id="22135" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#2207" class="Function">≤-total</a><a id="22142" class="Symbol">;</a>
                                  <a id="22178" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#11056" class="Function">+-monoʳ-≤</a><a id="22187" class="Symbol">;</a> <a id="22189" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#10966" class="Function">+-monoˡ-≤</a><a id="22198" class="Symbol">;</a> <a id="22200" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#10810" class="Function">+-mono-≤</a><a id="22208" class="Symbol">)</a></pre>
<p>In the standard library, <code class="highlighter-rouge">≤-total</code> is formalised in terms of
disjunction (which we define in Chapter <a href="/Connectives/">Connectives</a>),
and <code class="highlighter-rouge">+-monoʳ-≤</code>, <code class="highlighter-rouge">+-monoˡ-≤</code>, <code class="highlighter-rouge">+-mono-≤</code> are proved differently than here
as well as taking as implicit arguments that here are explicit.</p>

<h2 id="unicode">Unicode</h2>

<p>This chapter uses the following unicode.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>≤  U+2264  LESS-THAN OR EQUAL TO (\&lt;=, \le)
≥  U+2265  GREATER-THAN OR EQUAL TO (\&gt;=, \ge)
ˡ  U+02E1  MODIFIER LETTER SMALL L (\^l)
ʳ  U+02B3  MODIFIER LETTER SMALL R (\^r)
</code></pre></div></div>

<p>The commands <code class="highlighter-rouge">\^l</code> and <code class="highlighter-rouge">\^r</code> give access to a variety of superscript
leftward and rightward arrows in addition to superscript letters <code class="highlighter-rouge">l</code> and <code class="highlighter-rouge">r</code>.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Programming Language Foundations in Agda
</h2><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wenkokke"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wenkokke</span></a></li><li><a href="https://www.twitter.com/wenkokke"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wenkokke</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wadler"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wadler</span></a></li><li><a href="https://www.twitter.com/philipwadler"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">philipwadler</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div></div>

</footer>
<!-- Import jQuery -->
<script type="text/javascript" src="/assets/jquery.js"></script>

<!-- Script which allows for foldable code blocks -->
<script type="text/javascript">
 $('div.foldable pre').each(function(){
     var autoHeight = $(this).height();
     var lineHeight = parseFloat($(this).css('line-height'));

     var plus    = $("<div></div>");
     var horLine = $("<div></div>");
     var verLine = $("<div></div>");
     $(this).prepend(plus);
     plus.css({
         'position'         : 'relative',
         'float'            : 'right',
         'right'            : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'width'            : lineHeight,
         'height'           : lineHeight});
     verLine.css({
         'position'         : 'relative',
         'height'           : lineHeight,
         'width'            : '3px',
         'background-color' : '#C1E0FF'});
     horLine.css({
         'position'         : 'relative',
         'top'              : '-' + (0.5 * lineHeight + 1.5) + 'px',
         'left'             : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'height'           : '3px',
         'width'            : lineHeight,
         'background-color' : '#C1E0FF'});
     plus.append(verLine);
     plus.append(horLine);

     $(this).height(2.0 * lineHeight);
     $(this).css('overflow','hidden');

     $(this).click(function(){
         if ($(this).height() == autoHeight) {
             $(this).height(2.0 * lineHeight);
             plus.show();
         }
         else {
             $(this).height('auto');
             plus.hide();
         }
     });
 });
</script>

<!-- Import KaTeX -->
<script type="text/javascript" src="/assets/katex.js"></script>

<!-- Script which renders TeX using KaTeX -->
<script type="text/javascript">
 $("script[type='math/tex']").replaceWith(
     function(){
         var tex = $(this).text();
         return "<span class=\"inline-equation\">" +
                katex.renderToString(tex) +
                "</span>";
     });
 $("script[type='math/tex; mode=display']").replaceWith(
     function(){
         var tex = $(this).text().replace(/%.*?(\n|$)/g,"");
         return "<div class=\"equation\">" +
                katex.renderToString("\\displaystyle "+tex) +
                "</div>";
     });
</script>
</body>

</html>
