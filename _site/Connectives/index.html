<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Connectives: Conjunction, disjunction, and implication | Programming Language Foundations in Agda</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="Connectives: Conjunction, disjunction, and implication" />
<meta name="author" content="Wen Kokke" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Programming Language Foundations in Agda" />
<meta property="og:description" content="Programming Language Foundations in Agda" />
<link rel="canonical" href="https://plfa.ed.inf.ac.uk/Connectives/" />
<meta property="og:url" content="https://plfa.ed.inf.ac.uk/Connectives/" />
<meta property="og:site_name" content="Programming Language Foundations in Agda" />
<script type="application/ld+json">
{"description":"Programming Language Foundations in Agda","author":{"@type":"Person","name":"Wen Kokke"},"@type":"WebPage","url":"https://plfa.ed.inf.ac.uk/Connectives/","headline":"Connectives: Conjunction, disjunction, and implication","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://plfa.ed.inf.ac.uk/feed.xml" title="Programming Language Foundations in Agda
" /></head>
<body><header class="site-header" role="banner">

    <div class="wrapper">

        <a class="site-title" href="/">Programming Language Foundations in Agda
</a>

        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="/">Table of Contents</a>
                <a class="page-link" href="/about/">About</a>
            </div>
        </nav>

    </div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Connectives: Conjunction, disjunction, and implication</h1>
  </header>

  <div class="post-content">
    <pre class="Agda"><a id="135" class="Keyword">module</a> <a id="142" href="/Connectives/" class="Module">plfa.Connectives</a> <a id="159" class="Keyword">where</a></pre>

<p>This chapter introduces the basic logical connectives, by observing a
correspondence between connectives of logic and data types, a
principle known as <em>Propositions as Types</em>.</p>

<ul>
  <li><em>conjunction</em> is <em>product</em></li>
  <li><em>disjunction</em> is <em>sum</em></li>
  <li><em>true</em> is <em>unit type</em></li>
  <li><em>false</em> is <em>empty type</em></li>
  <li><em>implication</em> is <em>function space</em></li>
</ul>

<h2 id="imports">Imports</h2>

<pre class="Agda"><a id="531" class="Keyword">import</a> <a id="538" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="576" class="Symbol">as</a> <a id="579" class="Module">Eq</a>
<a id="582" class="Keyword">open</a> <a id="587" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="590" class="Keyword">using</a> <a id="596" class="Symbol">(</a><a id="597" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">_≡_</a><a id="600" class="Symbol">;</a> <a id="602" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="606" class="Symbol">;</a> <a id="608" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#560" class="Function">sym</a><a id="611" class="Symbol">;</a> <a id="613" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#627" class="Function">trans</a><a id="618" class="Symbol">;</a> <a id="620" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1075" class="Function">cong</a><a id="624" class="Symbol">)</a>
<a id="626" class="Keyword">open</a> <a id="631" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#3861" class="Module">Eq.≡-Reasoning</a>
<a id="646" class="Keyword">open</a> <a id="651" class="Keyword">import</a> <a id="658" href="https://agda.github.io/agda-stdlib/Data.Nat.html" class="Module">Data.Nat</a> <a id="667" class="Keyword">using</a> <a id="673" class="Symbol">(</a><a id="674" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a><a id="675" class="Symbol">;</a> <a id="677" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#115" class="InductiveConstructor">zero</a><a id="681" class="Symbol">;</a> <a id="683" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#128" class="InductiveConstructor">suc</a><a id="686" class="Symbol">;</a> <a id="688" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#230" class="Primitive Operator">_+_</a><a id="691" class="Symbol">;</a> <a id="693" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#433" class="Primitive Operator">_*_</a><a id="696" class="Symbol">)</a>
<a id="698" class="Keyword">open</a> <a id="703" class="Keyword">import</a> <a id="710" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html" class="Module">Data.Nat.Properties</a> <a id="730" class="Keyword">using</a> <a id="736" class="Symbol">(</a><a id="737" href="https://agda.github.io/agda-stdlib/Data.Nat.Properties.html#7679" class="Function">+-suc</a><a id="742" class="Symbol">)</a>
<a id="744" class="Keyword">open</a> <a id="749" class="Keyword">import</a> <a id="756" href="https://agda.github.io/agda-stdlib/Function.html" class="Module">Function</a> <a id="765" class="Keyword">using</a> <a id="771" class="Symbol">(</a><a id="772" href="https://agda.github.io/agda-stdlib/Function.html#759" class="Function Operator">_∘_</a><a id="775" class="Symbol">)</a>
<a id="777" class="Keyword">open</a> <a id="782" class="Keyword">import</a> <a id="789" href="/Isomorphism/" class="Module">plfa.Isomorphism</a> <a id="806" class="Keyword">using</a> <a id="812" class="Symbol">(</a><a id="813" href="/Isomorphism/#4104" class="Record Operator">_≃_</a><a id="816" class="Symbol">;</a> <a id="818" href="/Isomorphism/#6789" class="Function">≃-sym</a><a id="823" class="Symbol">;</a> <a id="825" href="/Isomorphism/#7115" class="Function">≃-trans</a><a id="832" class="Symbol">;</a> <a id="834" href="/Isomorphism/#8777" class="Record Operator">_≲_</a><a id="837" class="Symbol">;</a> <a id="839" href="/Isomorphism/#2747" class="Postulate">extensionality</a><a id="853" class="Symbol">)</a>
<a id="855" class="Keyword">open</a> <a id="860" href="/Isomorphism/#8055" class="Module">plfa.Isomorphism.≃-Reasoning</a></pre>

<h2 id="conjunction-is-product">Conjunction is product</h2>

<p>Given two propositions <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code>, the conjunction <code class="highlighter-rouge">A × B</code> holds
if both <code class="highlighter-rouge">A</code> holds and <code class="highlighter-rouge">B</code> holds.  We formalise this idea by
declaring a suitable inductive type.</p>
<pre class="Agda"><a id="1105" class="Keyword">data</a> <a id="_×_"></a><a id="1110" href="/Connectives/#1110" class="Datatype Operator">_×_</a> <a id="1114" class="Symbol">:</a> <a id="1116" class="PrimitiveType">Set</a> <a id="1120" class="Symbol">→</a> <a id="1122" class="PrimitiveType">Set</a> <a id="1126" class="Symbol">→</a> <a id="1128" class="PrimitiveType">Set</a> <a id="1132" class="Keyword">where</a>
  <a id="_×_.⟨_,_⟩"></a><a id="1140" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨_,_⟩</a> <a id="1146" class="Symbol">:</a> <a id="1148" class="Symbol">∀</a> <a id="1150" class="Symbol">{</a><a id="1151" href="/Connectives/#1151" class="Bound">A</a> <a id="1153" href="/Connectives/#1153" class="Bound">B</a> <a id="1155" class="Symbol">:</a> <a id="1157" class="PrimitiveType">Set</a><a id="1160" class="Symbol">}</a> <a id="1162" class="Symbol">→</a> <a id="1164" href="/Connectives/#1151" class="Bound">A</a> <a id="1166" class="Symbol">→</a> <a id="1168" href="/Connectives/#1153" class="Bound">B</a> <a id="1170" class="Symbol">→</a> <a id="1172" href="/Connectives/#1151" class="Bound">A</a> <a id="1174" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="1176" href="/Connectives/#1153" class="Bound">B</a></pre>
<p>Evidence that <code class="highlighter-rouge">A × B</code> holds is of the form
<code class="highlighter-rouge">⟨ M , N ⟩</code>, where <code class="highlighter-rouge">M</code> provides evidence that <code class="highlighter-rouge">A</code> holds and
<code class="highlighter-rouge">N</code> provides evidence that <code class="highlighter-rouge">B</code> holds.  In the standard library,
the pair constructor is <code class="highlighter-rouge">_,_</code>, but here we rename it to
<code class="highlighter-rouge">⟨_,_⟩</code> so that comma is available for other notations
(in particular, lists and environments).</p>

<!--
By convention, we parenthesise pairs, even though `M , N` is also
accepted by Agda.
-->

<p>Given evidence that <code class="highlighter-rouge">A × B</code> holds, we can conclude that either
<code class="highlighter-rouge">A</code> holds or <code class="highlighter-rouge">B</code> holds.</p>
<pre class="Agda"><a id="proj₁"></a><a id="1703" href="/Connectives/#1703" class="Function">proj₁</a> <a id="1709" class="Symbol">:</a> <a id="1711" class="Symbol">∀</a> <a id="1713" class="Symbol">{</a><a id="1714" href="/Connectives/#1714" class="Bound">A</a> <a id="1716" href="/Connectives/#1716" class="Bound">B</a> <a id="1718" class="Symbol">:</a> <a id="1720" class="PrimitiveType">Set</a><a id="1723" class="Symbol">}</a> <a id="1725" class="Symbol">→</a> <a id="1727" href="/Connectives/#1714" class="Bound">A</a> <a id="1729" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="1731" href="/Connectives/#1716" class="Bound">B</a> <a id="1733" class="Symbol">→</a> <a id="1735" href="/Connectives/#1714" class="Bound">A</a>
<a id="1737" href="/Connectives/#1703" class="Function">proj₁</a> <a id="1743" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="1745" href="/Connectives/#1745" class="Bound">x</a> <a id="1747" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="1749" href="/Connectives/#1749" class="Bound">y</a> <a id="1751" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="1753" class="Symbol">=</a> <a id="1755" href="/Connectives/#1745" class="Bound">x</a>

<a id="proj₂"></a><a id="1758" href="/Connectives/#1758" class="Function">proj₂</a> <a id="1764" class="Symbol">:</a> <a id="1766" class="Symbol">∀</a> <a id="1768" class="Symbol">{</a><a id="1769" href="/Connectives/#1769" class="Bound">A</a> <a id="1771" href="/Connectives/#1771" class="Bound">B</a> <a id="1773" class="Symbol">:</a> <a id="1775" class="PrimitiveType">Set</a><a id="1778" class="Symbol">}</a> <a id="1780" class="Symbol">→</a> <a id="1782" href="/Connectives/#1769" class="Bound">A</a> <a id="1784" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="1786" href="/Connectives/#1771" class="Bound">B</a> <a id="1788" class="Symbol">→</a> <a id="1790" href="/Connectives/#1771" class="Bound">B</a>
<a id="1792" href="/Connectives/#1758" class="Function">proj₂</a> <a id="1798" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="1800" href="/Connectives/#1800" class="Bound">x</a> <a id="1802" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="1804" href="/Connectives/#1804" class="Bound">y</a> <a id="1806" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="1808" class="Symbol">=</a> <a id="1810" href="/Connectives/#1804" class="Bound">y</a></pre>
<p>If <code class="highlighter-rouge">L</code> provides evidence that <code class="highlighter-rouge">A × B</code> holds, then <code class="highlighter-rouge">proj₁ L</code> provides evidence
that <code class="highlighter-rouge">A</code> holds, and <code class="highlighter-rouge">proj₂ L</code> provides evidence that <code class="highlighter-rouge">B</code> holds.</p>

<p>Equivalently, we could also declare conjunction as a record type.</p>
<pre class="Agda"><a id="2045" class="Keyword">record</a> <a id="_×′_"></a><a id="2052" href="/Connectives/#2052" class="Record Operator">_×′_</a> <a id="2057" class="Symbol">(</a><a id="2058" href="/Connectives/#2058" class="Bound">A</a> <a id="2060" href="/Connectives/#2060" class="Bound">B</a> <a id="2062" class="Symbol">:</a> <a id="2064" class="PrimitiveType">Set</a><a id="2067" class="Symbol">)</a> <a id="2069" class="Symbol">:</a> <a id="2071" class="PrimitiveType">Set</a> <a id="2075" class="Keyword">where</a>
  <a id="2083" class="Keyword">field</a>
    <a id="_×′_.proj₁′"></a><a id="2093" href="/Connectives/#2093" class="Field">proj₁′</a> <a id="2100" class="Symbol">:</a> <a id="2102" href="/Connectives/#2058" class="Bound">A</a>
    <a id="_×′_.proj₂′"></a><a id="2108" href="/Connectives/#2108" class="Field">proj₂′</a> <a id="2115" class="Symbol">:</a> <a id="2117" href="/Connectives/#2060" class="Bound">B</a>
<a id="2119" class="Keyword">open</a> <a id="2124" href="/Connectives/#2052" class="Module Operator">_×′_</a></pre>
<p>Here record construction</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>record
  { proj₁′ = M
  ; proj₂′ = N
  }
</code></pre></div></div>

<p>corresponds to the term</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⟨ M , N ⟩
</code></pre></div></div>

<p>where <code class="highlighter-rouge">M</code> is a term of type <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">N</code> is a term of type <code class="highlighter-rouge">B</code>.</p>

<p>When <code class="highlighter-rouge">⟨_,_⟩</code> appears in a term on the right-hand side of an equation
we refer to it as a <em>constructor</em>, and when it appears in a pattern on
the left-hand side of an equation we refer to it as a <em>destructor</em>.
We also refer to <code class="highlighter-rouge">proj₁</code> and <code class="highlighter-rouge">proj₂</code> as destructors, since they play a
similar role.  Other terminology refers to a constructor as
<em>introducing</em> a conjunction, and to a destructor as <em>eliminating</em> a
conjunction.  Indeed, <code class="highlighter-rouge">proj₁</code> and <code class="highlighter-rouge">proj₂</code> are sometimes given the
names <code class="highlighter-rouge">×-elim₁</code> and <code class="highlighter-rouge">×-elim₂</code>.</p>

<p>Applying each destructor and reassembling the results with the
constructor is the identity over products.</p>
<pre class="Agda"><a id="η-×"></a><a id="2952" href="/Connectives/#2952" class="Function">η-×</a> <a id="2956" class="Symbol">:</a> <a id="2958" class="Symbol">∀</a> <a id="2960" class="Symbol">{</a><a id="2961" href="/Connectives/#2961" class="Bound">A</a> <a id="2963" href="/Connectives/#2963" class="Bound">B</a> <a id="2965" class="Symbol">:</a> <a id="2967" class="PrimitiveType">Set</a><a id="2970" class="Symbol">}</a> <a id="2972" class="Symbol">(</a><a id="2973" href="/Connectives/#2973" class="Bound">w</a> <a id="2975" class="Symbol">:</a> <a id="2977" href="/Connectives/#2961" class="Bound">A</a> <a id="2979" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="2981" href="/Connectives/#2963" class="Bound">B</a><a id="2982" class="Symbol">)</a> <a id="2984" class="Symbol">→</a> <a id="2986" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="2988" href="/Connectives/#1703" class="Function">proj₁</a> <a id="2994" href="/Connectives/#2973" class="Bound">w</a> <a id="2996" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="2998" href="/Connectives/#1758" class="Function">proj₂</a> <a id="3004" href="/Connectives/#2973" class="Bound">w</a> <a id="3006" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="3008" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="3010" href="/Connectives/#2973" class="Bound">w</a>
<a id="3012" href="/Connectives/#2952" class="Function">η-×</a> <a id="3016" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="3018" href="/Connectives/#3018" class="Bound">x</a> <a id="3020" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="3022" href="/Connectives/#3022" class="Bound">y</a> <a id="3024" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="3026" class="Symbol">=</a> <a id="3028" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>
<p>The pattern matching on the left-hand side is essential, since
replacing <code class="highlighter-rouge">w</code> by <code class="highlighter-rouge">⟨ x , y ⟩</code> allows both sides of the equation to
simplify to the same term.</p>

<p>We set the precedence of conjunction so that it binds less
tightly than anything save disjunction.</p>
<pre class="Agda"><a id="3313" class="Keyword">infixr</a> <a id="3320" class="Number">2</a> <a id="3322" href="/Connectives/#1110" class="Datatype Operator">_×_</a></pre>
<p>Thus, <code class="highlighter-rouge">m ≤ n × n ≤ p</code> parses as <code class="highlighter-rouge">(m ≤ n) × (n ≤ p)</code>.</p>

<!--
and of the pairing operator so that it binds less tightly
than any arithmetic operator.
`(m * n , p)` parses as `((m * n) , p)`.
-->

<p>Given two types <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code>, we refer to <code class="highlighter-rouge">A x B</code> as the
<em>product</em> of <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code>.  In set theory, it is also sometimes
called the <em>cartesian product</em>, and in computing it corresponds
to a <em>record</em> type. Among other reasons for
calling it the product, note that if type <code class="highlighter-rouge">A</code> has <code class="highlighter-rouge">m</code>
distinct members, and type <code class="highlighter-rouge">B</code> has <code class="highlighter-rouge">n</code> distinct members,
then the type <code class="highlighter-rouge">A × B</code> has <code class="highlighter-rouge">m * n</code> distinct members.
For instance, consider a type <code class="highlighter-rouge">Bool</code> with two members, and
a type <code class="highlighter-rouge">Tri</code> with three members.</p>
<pre class="Agda"><a id="4025" class="Keyword">data</a> <a id="Bool"></a><a id="4030" href="/Connectives/#4030" class="Datatype">Bool</a> <a id="4035" class="Symbol">:</a> <a id="4037" class="PrimitiveType">Set</a> <a id="4041" class="Keyword">where</a>
  <a id="Bool.true"></a><a id="4049" href="/Connectives/#4049" class="InductiveConstructor">true</a> <a id="4054" class="Symbol">:</a> <a id="4056" href="/Connectives/#4030" class="Datatype">Bool</a>
  <a id="Bool.false"></a><a id="4063" href="/Connectives/#4063" class="InductiveConstructor">false</a> <a id="4069" class="Symbol">:</a> <a id="4071" href="/Connectives/#4030" class="Datatype">Bool</a>

<a id="4077" class="Keyword">data</a> <a id="Tri"></a><a id="4082" href="/Connectives/#4082" class="Datatype">Tri</a> <a id="4086" class="Symbol">:</a> <a id="4088" class="PrimitiveType">Set</a> <a id="4092" class="Keyword">where</a>
  <a id="Tri.aa"></a><a id="4100" href="/Connectives/#4100" class="InductiveConstructor">aa</a> <a id="4103" class="Symbol">:</a> <a id="4105" href="/Connectives/#4082" class="Datatype">Tri</a>
  <a id="Tri.bb"></a><a id="4111" href="/Connectives/#4111" class="InductiveConstructor">bb</a> <a id="4114" class="Symbol">:</a> <a id="4116" href="/Connectives/#4082" class="Datatype">Tri</a>
  <a id="Tri.cc"></a><a id="4122" href="/Connectives/#4122" class="InductiveConstructor">cc</a> <a id="4125" class="Symbol">:</a> <a id="4127" href="/Connectives/#4082" class="Datatype">Tri</a></pre>
<p>Then the type <code class="highlighter-rouge">Bool × Tri</code> has six members:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⟨ true  , aa ⟩    ⟨ true  , bb ⟩    ⟨ true ,  cc ⟩
⟨ false , aa ⟩    ⟨ false , bb ⟩    ⟨ false , cc ⟩
</code></pre></div></div>

<p>For example, the following function enumerates all
possible arguments of type <code class="highlighter-rouge">Bool × Tri</code>:</p>
<pre class="Agda"><a id="×-count"></a><a id="4403" href="/Connectives/#4403" class="Function">×-count</a> <a id="4411" class="Symbol">:</a> <a id="4413" href="/Connectives/#4030" class="Datatype">Bool</a> <a id="4418" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="4420" href="/Connectives/#4082" class="Datatype">Tri</a> <a id="4424" class="Symbol">→</a> <a id="4426" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a>
<a id="4428" href="/Connectives/#4403" class="Function">×-count</a> <a id="4436" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="4438" href="/Connectives/#4049" class="InductiveConstructor">true</a>  <a id="4444" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="4446" href="/Connectives/#4100" class="InductiveConstructor">aa</a> <a id="4449" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a>  <a id="4452" class="Symbol">=</a>  <a id="4455" class="Number">1</a>
<a id="4457" href="/Connectives/#4403" class="Function">×-count</a> <a id="4465" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="4467" href="/Connectives/#4049" class="InductiveConstructor">true</a>  <a id="4473" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="4475" href="/Connectives/#4111" class="InductiveConstructor">bb</a> <a id="4478" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a>  <a id="4481" class="Symbol">=</a>  <a id="4484" class="Number">2</a>
<a id="4486" href="/Connectives/#4403" class="Function">×-count</a> <a id="4494" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="4496" href="/Connectives/#4049" class="InductiveConstructor">true</a>  <a id="4502" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="4504" href="/Connectives/#4122" class="InductiveConstructor">cc</a> <a id="4507" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a>  <a id="4510" class="Symbol">=</a>  <a id="4513" class="Number">3</a>
<a id="4515" href="/Connectives/#4403" class="Function">×-count</a> <a id="4523" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="4525" href="/Connectives/#4063" class="InductiveConstructor">false</a> <a id="4531" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="4533" href="/Connectives/#4100" class="InductiveConstructor">aa</a> <a id="4536" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a>  <a id="4539" class="Symbol">=</a>  <a id="4542" class="Number">4</a>
<a id="4544" href="/Connectives/#4403" class="Function">×-count</a> <a id="4552" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="4554" href="/Connectives/#4063" class="InductiveConstructor">false</a> <a id="4560" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="4562" href="/Connectives/#4111" class="InductiveConstructor">bb</a> <a id="4565" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a>  <a id="4568" class="Symbol">=</a>  <a id="4571" class="Number">5</a>
<a id="4573" href="/Connectives/#4403" class="Function">×-count</a> <a id="4581" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="4583" href="/Connectives/#4063" class="InductiveConstructor">false</a> <a id="4589" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="4591" href="/Connectives/#4122" class="InductiveConstructor">cc</a> <a id="4594" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a>  <a id="4597" class="Symbol">=</a>  <a id="4600" class="Number">6</a></pre>

<p>Product on types also shares a property with product on numbers in
that there is a sense in which it is commutative and associative.  In
particular, product is commutative and associative <em>up to
isomorphism</em>.</p>

<p>For commutativity, the <code class="highlighter-rouge">to</code> function swaps a pair, taking <code class="highlighter-rouge">(x , y)</code> to
<code class="highlighter-rouge">(y , x)</code>, and the <code class="highlighter-rouge">from</code> function does the same (up to renaming).
Instantiating the patterns correctly in <code class="highlighter-rouge">from∘to</code> and <code class="highlighter-rouge">to∘from</code> is essential.
Replacing the definition of <code class="highlighter-rouge">from∘to</code> by <code class="highlighter-rouge">λ w → refl</code> will not work;
and similarly for <code class="highlighter-rouge">to∘from</code>, which does the same (up to renaming).</p>
<pre class="Agda"><a id="×-comm"></a><a id="5189" href="/Connectives/#5189" class="Function">×-comm</a> <a id="5196" class="Symbol">:</a> <a id="5198" class="Symbol">∀</a> <a id="5200" class="Symbol">{</a><a id="5201" href="/Connectives/#5201" class="Bound">A</a> <a id="5203" href="/Connectives/#5203" class="Bound">B</a> <a id="5205" class="Symbol">:</a> <a id="5207" class="PrimitiveType">Set</a><a id="5210" class="Symbol">}</a> <a id="5212" class="Symbol">→</a> <a id="5214" href="/Connectives/#5201" class="Bound">A</a> <a id="5216" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="5218" href="/Connectives/#5203" class="Bound">B</a> <a id="5220" href="/Isomorphism/#4104" class="Record Operator">≃</a> <a id="5222" href="/Connectives/#5203" class="Bound">B</a> <a id="5224" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="5226" href="/Connectives/#5201" class="Bound">A</a>
<a id="5228" href="/Connectives/#5189" class="Function">×-comm</a> <a id="5235" class="Symbol">=</a>
  <a id="5239" class="Keyword">record</a>
    <a id="5250" class="Symbol">{</a> <a id="5252" class="Field">to</a>       <a id="5261" class="Symbol">=</a>  <a id="5264" class="Symbol">λ{</a> <a id="5267" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="5269" href="/Connectives/#5269" class="Bound">x</a> <a id="5271" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="5273" href="/Connectives/#5273" class="Bound">y</a> <a id="5275" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="5277" class="Symbol">→</a> <a id="5279" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="5281" href="/Connectives/#5273" class="Bound">y</a> <a id="5283" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="5285" href="/Connectives/#5269" class="Bound">x</a> <a id="5287" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="5289" class="Symbol">}</a>
    <a id="5295" class="Symbol">;</a> <a id="5297" class="Field">from</a>     <a id="5306" class="Symbol">=</a>  <a id="5309" class="Symbol">λ{</a> <a id="5312" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="5314" href="/Connectives/#5314" class="Bound">y</a> <a id="5316" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="5318" href="/Connectives/#5318" class="Bound">x</a> <a id="5320" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="5322" class="Symbol">→</a> <a id="5324" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="5326" href="/Connectives/#5318" class="Bound">x</a> <a id="5328" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="5330" href="/Connectives/#5314" class="Bound">y</a> <a id="5332" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="5334" class="Symbol">}</a>
    <a id="5340" class="Symbol">;</a> <a id="5342" class="Field">from∘to</a>  <a id="5351" class="Symbol">=</a>  <a id="5354" class="Symbol">λ{</a> <a id="5357" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="5359" href="/Connectives/#5359" class="Bound">x</a> <a id="5361" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="5363" href="/Connectives/#5363" class="Bound">y</a> <a id="5365" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="5367" class="Symbol">→</a> <a id="5369" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="5374" class="Symbol">}</a>
    <a id="5380" class="Symbol">;</a> <a id="5382" class="Field">to∘from</a>  <a id="5391" class="Symbol">=</a>  <a id="5394" class="Symbol">λ{</a> <a id="5397" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="5399" href="/Connectives/#5399" class="Bound">y</a> <a id="5401" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="5403" href="/Connectives/#5403" class="Bound">x</a> <a id="5405" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="5407" class="Symbol">→</a> <a id="5409" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="5414" class="Symbol">}</a>
    <a id="5420" class="Symbol">}</a></pre>

<p>Being <em>commutative</em> is different from being <em>commutative up to
isomorphism</em>.  Compare the two statements:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m * n ≡ n * m
A × B ≃ B × A
</code></pre></div></div>

<p>In the first case, we might have that <code class="highlighter-rouge">m</code> is <code class="highlighter-rouge">2</code> and <code class="highlighter-rouge">n</code> is <code class="highlighter-rouge">3</code>, and
both <code class="highlighter-rouge">m * n</code> and <code class="highlighter-rouge">n * m</code> are equal to <code class="highlighter-rouge">6</code>.  In the second case, we
might have that <code class="highlighter-rouge">A</code> is <code class="highlighter-rouge">Bool</code> and <code class="highlighter-rouge">B</code> is <code class="highlighter-rouge">Tri</code>, and <code class="highlighter-rouge">Bool × Tri</code> is
<em>not</em> the same as <code class="highlighter-rouge">Tri × Bool</code>.  But there is an isomorphism
between the two types.  For
instance, <code class="highlighter-rouge">(true , aa)</code>, which is a member of the former, corresponds
to <code class="highlighter-rouge">(aa , true)</code>, which is a member of the latter.</p>

<p>For associativity, the <code class="highlighter-rouge">to</code> function reassociates two uses of pairing,
taking <code class="highlighter-rouge">((x , y) , z)</code> to <code class="highlighter-rouge">(x , (y , z))</code>, and the <code class="highlighter-rouge">from</code> function does
the inverse.  Again, the evidence of left and right inverse requires
matching against a suitable pattern to enable simplification.</p>
<pre class="Agda"><a id="×-assoc"></a><a id="6280" href="/Connectives/#6280" class="Function">×-assoc</a> <a id="6288" class="Symbol">:</a> <a id="6290" class="Symbol">∀</a> <a id="6292" class="Symbol">{</a><a id="6293" href="/Connectives/#6293" class="Bound">A</a> <a id="6295" href="/Connectives/#6295" class="Bound">B</a> <a id="6297" href="/Connectives/#6297" class="Bound">C</a> <a id="6299" class="Symbol">:</a> <a id="6301" class="PrimitiveType">Set</a><a id="6304" class="Symbol">}</a> <a id="6306" class="Symbol">→</a> <a id="6308" class="Symbol">(</a><a id="6309" href="/Connectives/#6293" class="Bound">A</a> <a id="6311" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="6313" href="/Connectives/#6295" class="Bound">B</a><a id="6314" class="Symbol">)</a> <a id="6316" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="6318" href="/Connectives/#6297" class="Bound">C</a> <a id="6320" href="/Isomorphism/#4104" class="Record Operator">≃</a> <a id="6322" href="/Connectives/#6293" class="Bound">A</a> <a id="6324" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="6326" class="Symbol">(</a><a id="6327" href="/Connectives/#6295" class="Bound">B</a> <a id="6329" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="6331" href="/Connectives/#6297" class="Bound">C</a><a id="6332" class="Symbol">)</a>
<a id="6334" href="/Connectives/#6280" class="Function">×-assoc</a> <a id="6342" class="Symbol">=</a>
  <a id="6346" class="Keyword">record</a>
    <a id="6357" class="Symbol">{</a> <a id="6359" class="Field">to</a>      <a id="6367" class="Symbol">=</a> <a id="6369" class="Symbol">λ{</a> <a id="6372" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="6374" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="6376" href="/Connectives/#6376" class="Bound">x</a> <a id="6378" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="6380" href="/Connectives/#6380" class="Bound">y</a> <a id="6382" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="6384" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="6386" href="/Connectives/#6386" class="Bound">z</a> <a id="6388" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="6390" class="Symbol">→</a> <a id="6392" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="6394" href="/Connectives/#6376" class="Bound">x</a> <a id="6396" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="6398" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="6400" href="/Connectives/#6380" class="Bound">y</a> <a id="6402" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="6404" href="/Connectives/#6386" class="Bound">z</a> <a id="6406" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="6408" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="6410" class="Symbol">}</a>
    <a id="6416" class="Symbol">;</a> <a id="6418" class="Field">from</a>    <a id="6426" class="Symbol">=</a> <a id="6428" class="Symbol">λ{</a> <a id="6431" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="6433" href="/Connectives/#6433" class="Bound">x</a> <a id="6435" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="6437" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="6439" href="/Connectives/#6439" class="Bound">y</a> <a id="6441" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="6443" href="/Connectives/#6443" class="Bound">z</a> <a id="6445" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="6447" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="6449" class="Symbol">→</a> <a id="6451" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="6453" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="6455" href="/Connectives/#6433" class="Bound">x</a> <a id="6457" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="6459" href="/Connectives/#6439" class="Bound">y</a> <a id="6461" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="6463" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="6465" href="/Connectives/#6443" class="Bound">z</a> <a id="6467" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="6469" class="Symbol">}</a>
    <a id="6475" class="Symbol">;</a> <a id="6477" class="Field">from∘to</a> <a id="6485" class="Symbol">=</a> <a id="6487" class="Symbol">λ{</a> <a id="6490" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="6492" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="6494" href="/Connectives/#6494" class="Bound">x</a> <a id="6496" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="6498" href="/Connectives/#6498" class="Bound">y</a> <a id="6500" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="6502" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="6504" href="/Connectives/#6504" class="Bound">z</a> <a id="6506" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="6508" class="Symbol">→</a> <a id="6510" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="6515" class="Symbol">}</a>
    <a id="6521" class="Symbol">;</a> <a id="6523" class="Field">to∘from</a> <a id="6531" class="Symbol">=</a> <a id="6533" class="Symbol">λ{</a> <a id="6536" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="6538" href="/Connectives/#6538" class="Bound">x</a> <a id="6540" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="6542" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="6544" href="/Connectives/#6544" class="Bound">y</a> <a id="6546" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="6548" href="/Connectives/#6548" class="Bound">z</a> <a id="6550" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="6552" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="6554" class="Symbol">→</a> <a id="6556" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="6561" class="Symbol">}</a>
    <a id="6567" class="Symbol">}</a></pre>

<p>Being <em>associative</em> is not the same as being <em>associative
up to isomorphism</em>.  Compare the two statements:</p>

<p>(m * n) * p ≡ m * (n * p)
  (A × B) × C ≃ A × (B × C)</p>

<p>For example, the type <code class="highlighter-rouge">(ℕ × Bool) × Tri</code> is <em>not</em> the same as <code class="highlighter-rouge">ℕ ×
(Bool × Tri)</code>. But there is an isomorphism between the two types. For
instance <code class="highlighter-rouge">((1 , true) , aa)</code>, which is a member of the former,
corresponds to <code class="highlighter-rouge">(1 , (true , aa))</code>, which is a member of the latter.</p>

<h2 id="truth-is-unit">Truth is unit</h2>

<p>Truth <code class="highlighter-rouge">⊤</code> always holds. We formalise this idea by
declaring a suitable inductive type.</p>
<pre class="Agda"><a id="7134" class="Keyword">data</a> <a id="⊤"></a><a id="7139" href="/Connectives/#7139" class="Datatype">⊤</a> <a id="7141" class="Symbol">:</a> <a id="7143" class="PrimitiveType">Set</a> <a id="7147" class="Keyword">where</a>
  <a id="⊤.tt"></a><a id="7155" href="/Connectives/#7155" class="InductiveConstructor">tt</a> <a id="7158" class="Symbol">:</a> <a id="7160" href="/Connectives/#7139" class="Datatype">⊤</a></pre>
<p>Evidence that <code class="highlighter-rouge">⊤</code> holds is of the form <code class="highlighter-rouge">tt</code>.</p>

<p>Given evidence that <code class="highlighter-rouge">⊤</code> holds, there is nothing more of interest we
can conclude.  Since truth always holds, knowing that it holds tells
us nothing new.</p>

<p>The nullary case of <code class="highlighter-rouge">η-×</code> is <code class="highlighter-rouge">η-⊤</code>, which asserts that any
term of type <code class="highlighter-rouge">⊤</code> must be equal to <code class="highlighter-rouge">tt</code>.</p>
<pre class="Agda"><a id="η-⊤"></a><a id="7485" href="/Connectives/#7485" class="Function">η-⊤</a> <a id="7489" class="Symbol">:</a> <a id="7491" class="Symbol">∀</a> <a id="7493" class="Symbol">(</a><a id="7494" href="/Connectives/#7494" class="Bound">w</a> <a id="7496" class="Symbol">:</a> <a id="7498" href="/Connectives/#7139" class="Datatype">⊤</a><a id="7499" class="Symbol">)</a> <a id="7501" class="Symbol">→</a> <a id="7503" href="/Connectives/#7155" class="InductiveConstructor">tt</a> <a id="7506" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="7508" href="/Connectives/#7494" class="Bound">w</a>
<a id="7510" href="/Connectives/#7485" class="Function">η-⊤</a> <a id="7514" href="/Connectives/#7155" class="InductiveConstructor">tt</a> <a id="7517" class="Symbol">=</a> <a id="7519" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>
<p>The pattern matching on the left-hand side is essential.  Replacing
<code class="highlighter-rouge">w</code> by <code class="highlighter-rouge">tt</code> allows both sides of the equation to simplify to the
same term.</p>

<p>We refer to <code class="highlighter-rouge">⊤</code> as the <em>unit</em> type. And, indeed,
type <code class="highlighter-rouge">⊤</code> has exactly once member, <code class="highlighter-rouge">tt</code>.  For example, the following
function enumerates all possible arguments of type <code class="highlighter-rouge">⊤</code>:</p>
<pre class="Agda"><a id="⊤-count"></a><a id="7866" href="/Connectives/#7866" class="Function">⊤-count</a> <a id="7874" class="Symbol">:</a> <a id="7876" href="/Connectives/#7139" class="Datatype">⊤</a> <a id="7878" class="Symbol">→</a> <a id="7880" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a>
<a id="7882" href="/Connectives/#7866" class="Function">⊤-count</a> <a id="7890" href="/Connectives/#7155" class="InductiveConstructor">tt</a> <a id="7893" class="Symbol">=</a> <a id="7895" class="Number">1</a></pre>

<p>For numbers, one is the identity of multiplication. Correspondingly,
unit is the identity of product <em>up to isomorphism</em>.  For left
identity, the <code class="highlighter-rouge">to</code> function takes <code class="highlighter-rouge">(tt , x)</code> to <code class="highlighter-rouge">x</code>, and the <code class="highlighter-rouge">from</code>
function does the inverse.  The evidence of left inverse requires
matching against a suitable pattern to enable simplification.</p>
<pre class="Agda"><a id="⊤-identityˡ"></a><a id="8250" href="/Connectives/#8250" class="Function">⊤-identityˡ</a> <a id="8262" class="Symbol">:</a> <a id="8264" class="Symbol">∀</a> <a id="8266" class="Symbol">{</a><a id="8267" href="/Connectives/#8267" class="Bound">A</a> <a id="8269" class="Symbol">:</a> <a id="8271" class="PrimitiveType">Set</a><a id="8274" class="Symbol">}</a> <a id="8276" class="Symbol">→</a> <a id="8278" href="/Connectives/#7139" class="Datatype">⊤</a> <a id="8280" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="8282" href="/Connectives/#8267" class="Bound">A</a> <a id="8284" href="/Isomorphism/#4104" class="Record Operator">≃</a> <a id="8286" href="/Connectives/#8267" class="Bound">A</a>
<a id="8288" href="/Connectives/#8250" class="Function">⊤-identityˡ</a> <a id="8300" class="Symbol">=</a>
  <a id="8304" class="Keyword">record</a>
    <a id="8315" class="Symbol">{</a> <a id="8317" class="Field">to</a>      <a id="8325" class="Symbol">=</a> <a id="8327" class="Symbol">λ{</a> <a id="8330" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="8332" href="/Connectives/#7155" class="InductiveConstructor">tt</a> <a id="8335" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="8337" href="/Connectives/#8337" class="Bound">x</a> <a id="8339" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="8341" class="Symbol">→</a> <a id="8343" href="/Connectives/#8337" class="Bound">x</a> <a id="8345" class="Symbol">}</a>
    <a id="8351" class="Symbol">;</a> <a id="8353" class="Field">from</a>    <a id="8361" class="Symbol">=</a> <a id="8363" class="Symbol">λ{</a> <a id="8366" href="/Connectives/#8366" class="Bound">x</a> <a id="8368" class="Symbol">→</a> <a id="8370" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="8372" href="/Connectives/#7155" class="InductiveConstructor">tt</a> <a id="8375" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="8377" href="/Connectives/#8366" class="Bound">x</a> <a id="8379" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="8381" class="Symbol">}</a>
    <a id="8387" class="Symbol">;</a> <a id="8389" class="Field">from∘to</a> <a id="8397" class="Symbol">=</a> <a id="8399" class="Symbol">λ{</a> <a id="8402" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="8404" href="/Connectives/#7155" class="InductiveConstructor">tt</a> <a id="8407" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="8409" href="/Connectives/#8409" class="Bound">x</a> <a id="8411" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="8413" class="Symbol">→</a> <a id="8415" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="8420" class="Symbol">}</a>
    <a id="8426" class="Symbol">;</a> <a id="8428" class="Field">to∘from</a> <a id="8436" class="Symbol">=</a> <a id="8438" class="Symbol">λ{</a> <a id="8441" href="/Connectives/#8441" class="Bound">x</a> <a id="8443" class="Symbol">→</a> <a id="8445" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="8450" class="Symbol">}</a>
    <a id="8456" class="Symbol">}</a></pre>

<p>Having an <em>identity</em> is different from having an identity
<em>up to isomorphism</em>.  Compare the two statements:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 * m ≡ m
⊤ × A ≃ A
</code></pre></div></div>

<p>In the first case, we might have that <code class="highlighter-rouge">m</code> is <code class="highlighter-rouge">2</code>, and both
<code class="highlighter-rouge">1 * m</code> and <code class="highlighter-rouge">m</code> are equal to <code class="highlighter-rouge">2</code>.  In the second
case, we might have that <code class="highlighter-rouge">A</code> is <code class="highlighter-rouge">Bool</code>, and <code class="highlighter-rouge">⊤ × Bool</code> is <em>not</em> the
same as <code class="highlighter-rouge">Bool</code>.  But there is an isomorphism between the two types.
For instance, <code class="highlighter-rouge">(tt, true)</code>, which is a member of the former,
corresponds to <code class="highlighter-rouge">true</code>, which is a member of the latter.</p>

<p>Right identity follows from commutativity of product and left identity.</p>
<pre class="Agda"><a id="⊤-identityʳ"></a><a id="9055" href="/Connectives/#9055" class="Function">⊤-identityʳ</a> <a id="9067" class="Symbol">:</a> <a id="9069" class="Symbol">∀</a> <a id="9071" class="Symbol">{</a><a id="9072" href="/Connectives/#9072" class="Bound">A</a> <a id="9074" class="Symbol">:</a> <a id="9076" class="PrimitiveType">Set</a><a id="9079" class="Symbol">}</a> <a id="9081" class="Symbol">→</a> <a id="9083" class="Symbol">(</a><a id="9084" href="/Connectives/#9072" class="Bound">A</a> <a id="9086" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="9088" href="/Connectives/#7139" class="Datatype">⊤</a><a id="9089" class="Symbol">)</a> <a id="9091" href="/Isomorphism/#4104" class="Record Operator">≃</a> <a id="9093" href="/Connectives/#9072" class="Bound">A</a>
<a id="9095" href="/Connectives/#9055" class="Function">⊤-identityʳ</a> <a id="9107" class="Symbol">{</a><a id="9108" href="/Connectives/#9108" class="Bound">A</a><a id="9109" class="Symbol">}</a> <a id="9111" class="Symbol">=</a>
  <a id="9115" href="/Isomorphism/#8131" class="Function Operator">≃-begin</a>
    <a id="9127" class="Symbol">(</a><a id="9128" href="/Connectives/#9108" class="Bound">A</a> <a id="9130" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="9132" href="/Connectives/#7139" class="Datatype">⊤</a><a id="9133" class="Symbol">)</a>
  <a id="9137" href="/Isomorphism/#8195" class="Function Operator">≃⟨</a> <a id="9140" href="/Connectives/#5189" class="Function">×-comm</a> <a id="9147" href="/Isomorphism/#8195" class="Function Operator">⟩</a>
    <a id="9153" class="Symbol">(</a><a id="9154" href="/Connectives/#7139" class="Datatype">⊤</a> <a id="9156" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="9158" href="/Connectives/#9108" class="Bound">A</a><a id="9159" class="Symbol">)</a>
  <a id="9163" href="/Isomorphism/#8195" class="Function Operator">≃⟨</a> <a id="9166" href="/Connectives/#8250" class="Function">⊤-identityˡ</a> <a id="9178" href="/Isomorphism/#8195" class="Function Operator">⟩</a>
    <a id="9184" href="/Connectives/#9108" class="Bound">A</a>
  <a id="9188" href="/Isomorphism/#8290" class="Function Operator">≃-∎</a></pre>
<p>Here we have used a chain of isomorphisms,
analogous to that used for equality.</p>

<h2 id="disjunction-is-sum">Disjunction is sum</h2>

<p>Given two propositions <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code>, the disjunction <code class="highlighter-rouge">A ⊎ B</code> holds
if either <code class="highlighter-rouge">A</code> holds or <code class="highlighter-rouge">B</code> holds.  We formalise this idea by
declaring a suitable inductive type.</p>
<pre class="Agda"><a id="9485" class="Keyword">data</a> <a id="_⊎_"></a><a id="9490" href="/Connectives/#9490" class="Datatype Operator">_⊎_</a> <a id="9494" class="Symbol">:</a> <a id="9496" class="PrimitiveType">Set</a> <a id="9500" class="Symbol">→</a> <a id="9502" class="PrimitiveType">Set</a> <a id="9506" class="Symbol">→</a> <a id="9508" class="PrimitiveType">Set</a> <a id="9512" class="Keyword">where</a>
  <a id="_⊎_.inj₁"></a><a id="9520" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="9525" class="Symbol">:</a> <a id="9527" class="Symbol">∀</a> <a id="9529" class="Symbol">{</a><a id="9530" href="/Connectives/#9530" class="Bound">A</a> <a id="9532" href="/Connectives/#9532" class="Bound">B</a> <a id="9534" class="Symbol">:</a> <a id="9536" class="PrimitiveType">Set</a><a id="9539" class="Symbol">}</a> <a id="9541" class="Symbol">→</a> <a id="9543" href="/Connectives/#9530" class="Bound">A</a> <a id="9545" class="Symbol">→</a> <a id="9547" href="/Connectives/#9530" class="Bound">A</a> <a id="9549" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="9551" href="/Connectives/#9532" class="Bound">B</a>
  <a id="_⊎_.inj₂"></a><a id="9555" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="9560" class="Symbol">:</a> <a id="9562" class="Symbol">∀</a> <a id="9564" class="Symbol">{</a><a id="9565" href="/Connectives/#9565" class="Bound">A</a> <a id="9567" href="/Connectives/#9567" class="Bound">B</a> <a id="9569" class="Symbol">:</a> <a id="9571" class="PrimitiveType">Set</a><a id="9574" class="Symbol">}</a> <a id="9576" class="Symbol">→</a> <a id="9578" href="/Connectives/#9567" class="Bound">B</a> <a id="9580" class="Symbol">→</a> <a id="9582" href="/Connectives/#9565" class="Bound">A</a> <a id="9584" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="9586" href="/Connectives/#9567" class="Bound">B</a></pre>
<p>Evidence that <code class="highlighter-rouge">A ⊎ B</code> holds is either of the form <code class="highlighter-rouge">inj₁ M</code>, where <code class="highlighter-rouge">M</code>
provides evidence that <code class="highlighter-rouge">A</code> holds, or <code class="highlighter-rouge">inj₂ N</code>, where <code class="highlighter-rouge">N</code> provides
evidence that <code class="highlighter-rouge">B</code> holds.</p>

<p>Given evidence that <code class="highlighter-rouge">A → C</code> and <code class="highlighter-rouge">B → C</code> both hold, then given
evidence that <code class="highlighter-rouge">A ⊎ B</code> holds we can conclude that <code class="highlighter-rouge">C</code> holds.</p>
<pre class="Agda"><a id="⊎-elim"></a><a id="9896" href="/Connectives/#9896" class="Function">⊎-elim</a> <a id="9903" class="Symbol">:</a> <a id="9905" class="Symbol">∀</a> <a id="9907" class="Symbol">{</a><a id="9908" href="/Connectives/#9908" class="Bound">A</a> <a id="9910" href="/Connectives/#9910" class="Bound">B</a> <a id="9912" href="/Connectives/#9912" class="Bound">C</a> <a id="9914" class="Symbol">:</a> <a id="9916" class="PrimitiveType">Set</a><a id="9919" class="Symbol">}</a> <a id="9921" class="Symbol">→</a> <a id="9923" class="Symbol">(</a><a id="9924" href="/Connectives/#9908" class="Bound">A</a> <a id="9926" class="Symbol">→</a> <a id="9928" href="/Connectives/#9912" class="Bound">C</a><a id="9929" class="Symbol">)</a> <a id="9931" class="Symbol">→</a> <a id="9933" class="Symbol">(</a><a id="9934" href="/Connectives/#9910" class="Bound">B</a> <a id="9936" class="Symbol">→</a> <a id="9938" href="/Connectives/#9912" class="Bound">C</a><a id="9939" class="Symbol">)</a> <a id="9941" class="Symbol">→</a> <a id="9943" class="Symbol">(</a><a id="9944" href="/Connectives/#9908" class="Bound">A</a> <a id="9946" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="9948" href="/Connectives/#9910" class="Bound">B</a> <a id="9950" class="Symbol">→</a> <a id="9952" href="/Connectives/#9912" class="Bound">C</a><a id="9953" class="Symbol">)</a>
<a id="9955" href="/Connectives/#9896" class="Function">⊎-elim</a> <a id="9962" href="/Connectives/#9962" class="Bound">f</a> <a id="9964" href="/Connectives/#9964" class="Bound">g</a> <a id="9966" class="Symbol">(</a><a id="9967" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="9972" href="/Connectives/#9972" class="Bound">x</a><a id="9973" class="Symbol">)</a> <a id="9975" class="Symbol">=</a> <a id="9977" href="/Connectives/#9962" class="Bound">f</a> <a id="9979" href="/Connectives/#9972" class="Bound">x</a>
<a id="9981" href="/Connectives/#9896" class="Function">⊎-elim</a> <a id="9988" href="/Connectives/#9988" class="Bound">f</a> <a id="9990" href="/Connectives/#9990" class="Bound">g</a> <a id="9992" class="Symbol">(</a><a id="9993" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="9998" href="/Connectives/#9998" class="Bound">y</a><a id="9999" class="Symbol">)</a> <a id="10001" class="Symbol">=</a> <a id="10003" href="/Connectives/#9990" class="Bound">g</a> <a id="10005" href="/Connectives/#9998" class="Bound">y</a></pre>
<p>Pattern matching against <code class="highlighter-rouge">inj₁</code> and <code class="highlighter-rouge">inj₂</code> is typical of how we exploit
evidence that a disjunction holds.</p>

<p>When <code class="highlighter-rouge">inj₁</code> and <code class="highlighter-rouge">inj₂</code> appear on the right-hand side of an equation we
refer to them as <em>constructors</em>, and when they appears on the
left-hand side we refer to them as <em>destructors</em>.  We also refer
to <code class="highlighter-rouge">⊎-elim</code> as a destructor, since it plays a similar role.
Other terminology refers to constructors as <em>introducing</em> a disjunction,
and to a destructors as <em>eliminating</em> a disjunction.</p>

<p>Applying the destructor to each of the constructors is the identity.</p>
<pre class="Agda"><a id="η-⊎"></a><a id="10593" href="/Connectives/#10593" class="Function">η-⊎</a> <a id="10597" class="Symbol">:</a> <a id="10599" class="Symbol">∀</a> <a id="10601" class="Symbol">{</a><a id="10602" href="/Connectives/#10602" class="Bound">A</a> <a id="10604" href="/Connectives/#10604" class="Bound">B</a> <a id="10606" class="Symbol">:</a> <a id="10608" class="PrimitiveType">Set</a><a id="10611" class="Symbol">}</a> <a id="10613" class="Symbol">(</a><a id="10614" href="/Connectives/#10614" class="Bound">w</a> <a id="10616" class="Symbol">:</a> <a id="10618" href="/Connectives/#10602" class="Bound">A</a> <a id="10620" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="10622" href="/Connectives/#10604" class="Bound">B</a><a id="10623" class="Symbol">)</a> <a id="10625" class="Symbol">→</a> <a id="10627" href="/Connectives/#9896" class="Function">⊎-elim</a> <a id="10634" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="10639" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="10644" href="/Connectives/#10614" class="Bound">w</a> <a id="10646" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="10648" href="/Connectives/#10614" class="Bound">w</a>
<a id="10650" href="/Connectives/#10593" class="Function">η-⊎</a> <a id="10654" class="Symbol">(</a><a id="10655" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="10660" href="/Connectives/#10660" class="Bound">x</a><a id="10661" class="Symbol">)</a> <a id="10663" class="Symbol">=</a> <a id="10665" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="10670" href="/Connectives/#10593" class="Function">η-⊎</a> <a id="10674" class="Symbol">(</a><a id="10675" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="10680" href="/Connectives/#10680" class="Bound">y</a><a id="10681" class="Symbol">)</a> <a id="10683" class="Symbol">=</a> <a id="10685" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>
<p>More generally, we can also throw in an arbitrary function from a disjunction.</p>
<pre class="Agda"><a id="uniq-⊎"></a><a id="10793" href="/Connectives/#10793" class="Function">uniq-⊎</a> <a id="10800" class="Symbol">:</a> <a id="10802" class="Symbol">∀</a> <a id="10804" class="Symbol">{</a><a id="10805" href="/Connectives/#10805" class="Bound">A</a> <a id="10807" href="/Connectives/#10807" class="Bound">B</a> <a id="10809" href="/Connectives/#10809" class="Bound">C</a> <a id="10811" class="Symbol">:</a> <a id="10813" class="PrimitiveType">Set</a><a id="10816" class="Symbol">}</a> <a id="10818" class="Symbol">(</a><a id="10819" href="/Connectives/#10819" class="Bound">h</a> <a id="10821" class="Symbol">:</a> <a id="10823" href="/Connectives/#10805" class="Bound">A</a> <a id="10825" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="10827" href="/Connectives/#10807" class="Bound">B</a> <a id="10829" class="Symbol">→</a> <a id="10831" href="/Connectives/#10809" class="Bound">C</a><a id="10832" class="Symbol">)</a> <a id="10834" class="Symbol">(</a><a id="10835" href="/Connectives/#10835" class="Bound">w</a> <a id="10837" class="Symbol">:</a> <a id="10839" href="/Connectives/#10805" class="Bound">A</a> <a id="10841" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="10843" href="/Connectives/#10807" class="Bound">B</a><a id="10844" class="Symbol">)</a> <a id="10846" class="Symbol">→</a>
  <a id="10850" href="/Connectives/#9896" class="Function">⊎-elim</a> <a id="10857" class="Symbol">(</a><a id="10858" href="/Connectives/#10819" class="Bound">h</a> <a id="10860" href="https://agda.github.io/agda-stdlib/Function.html#759" class="Function Operator">∘</a> <a id="10862" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a><a id="10866" class="Symbol">)</a> <a id="10868" class="Symbol">(</a><a id="10869" href="/Connectives/#10819" class="Bound">h</a> <a id="10871" href="https://agda.github.io/agda-stdlib/Function.html#759" class="Function Operator">∘</a> <a id="10873" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a><a id="10877" class="Symbol">)</a> <a id="10879" href="/Connectives/#10835" class="Bound">w</a> <a id="10881" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="10883" href="/Connectives/#10819" class="Bound">h</a> <a id="10885" href="/Connectives/#10835" class="Bound">w</a>
<a id="10887" href="/Connectives/#10793" class="Function">uniq-⊎</a> <a id="10894" href="/Connectives/#10894" class="Bound">h</a> <a id="10896" class="Symbol">(</a><a id="10897" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="10902" href="/Connectives/#10902" class="Bound">x</a><a id="10903" class="Symbol">)</a> <a id="10905" class="Symbol">=</a> <a id="10907" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="10912" href="/Connectives/#10793" class="Function">uniq-⊎</a> <a id="10919" href="/Connectives/#10919" class="Bound">h</a> <a id="10921" class="Symbol">(</a><a id="10922" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="10927" href="/Connectives/#10927" class="Bound">y</a><a id="10928" class="Symbol">)</a> <a id="10930" class="Symbol">=</a> <a id="10932" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>
<p>The pattern matching on the left-hand side is essential.  Replacing
<code class="highlighter-rouge">w</code> by <code class="highlighter-rouge">inj₁ x</code> allows both sides of the equation to simplify to the
same term, and similarly for <code class="highlighter-rouge">inj₂ y</code>.</p>

<p>We set the precedence of disjunction so that it binds less tightly
than any other declared operator.</p>
<pre class="Agda"><a id="11239" class="Keyword">infix</a> <a id="11245" class="Number">1</a> <a id="11247" href="/Connectives/#9490" class="Datatype Operator">_⊎_</a></pre>
<p>Thus, <code class="highlighter-rouge">A × C ⊎ B × C</code> parses as <code class="highlighter-rouge">(A × C) ⊎ (B × C)</code>.</p>

<p>Given two types <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code>, we refer to <code class="highlighter-rouge">A ⊎ B</code> as the
<em>sum</em> of <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code>.  In set theory, it is also sometimes
called the <em>disjoint union</em>, and in computing it corresponds
to a <em>variant record</em> type. Among other reasons for
calling it the sum, note that if type <code class="highlighter-rouge">A</code> has <code class="highlighter-rouge">m</code>
distinct members, and type <code class="highlighter-rouge">B</code> has <code class="highlighter-rouge">n</code> distinct members,
then the type <code class="highlighter-rouge">A ⊎ B</code> has <code class="highlighter-rouge">m + n</code> distinct members.
For instance, consider a type <code class="highlighter-rouge">Bool</code> with two members, and
a type <code class="highlighter-rouge">Tri</code> with three members, as defined earlier.
Then the type <code class="highlighter-rouge">Bool ⊎ Tri</code> has five
members:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inj₁ true     inj₂ aa
inj₁ false    inj₂ bb
              inj₂ cc
</code></pre></div></div>

<p>For example, the following function enumerates all
possible arguments of type <code class="highlighter-rouge">Bool ⊎ Tri</code>:</p>
<pre class="Agda"><a id="⊎-count"></a><a id="12045" href="/Connectives/#12045" class="Function">⊎-count</a> <a id="12053" class="Symbol">:</a> <a id="12055" href="/Connectives/#4030" class="Datatype">Bool</a> <a id="12060" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="12062" href="/Connectives/#4082" class="Datatype">Tri</a> <a id="12066" class="Symbol">→</a> <a id="12068" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a>
<a id="12070" href="/Connectives/#12045" class="Function">⊎-count</a> <a id="12078" class="Symbol">(</a><a id="12079" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="12084" href="/Connectives/#4049" class="InductiveConstructor">true</a><a id="12088" class="Symbol">)</a>   <a id="12092" class="Symbol">=</a>  <a id="12095" class="Number">1</a>
<a id="12097" href="/Connectives/#12045" class="Function">⊎-count</a> <a id="12105" class="Symbol">(</a><a id="12106" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="12111" href="/Connectives/#4063" class="InductiveConstructor">false</a><a id="12116" class="Symbol">)</a>  <a id="12119" class="Symbol">=</a>  <a id="12122" class="Number">2</a>
<a id="12124" href="/Connectives/#12045" class="Function">⊎-count</a> <a id="12132" class="Symbol">(</a><a id="12133" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="12138" href="/Connectives/#4100" class="InductiveConstructor">aa</a><a id="12140" class="Symbol">)</a>     <a id="12146" class="Symbol">=</a>  <a id="12149" class="Number">3</a>
<a id="12151" href="/Connectives/#12045" class="Function">⊎-count</a> <a id="12159" class="Symbol">(</a><a id="12160" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="12165" href="/Connectives/#4111" class="InductiveConstructor">bb</a><a id="12167" class="Symbol">)</a>     <a id="12173" class="Symbol">=</a>  <a id="12176" class="Number">4</a>
<a id="12178" href="/Connectives/#12045" class="Function">⊎-count</a> <a id="12186" class="Symbol">(</a><a id="12187" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="12192" href="/Connectives/#4122" class="InductiveConstructor">cc</a><a id="12194" class="Symbol">)</a>     <a id="12200" class="Symbol">=</a>  <a id="12203" class="Number">5</a></pre>

<p>Sum on types also shares a property with sum on numbers in that it is
commutative and associative <em>up to isomorphism</em>.</p>

<p>For commutativity, the <code class="highlighter-rouge">to</code> function swaps the two constructors,
taking <code class="highlighter-rouge">inj₁ x</code> to <code class="highlighter-rouge">inj₂ x</code>, and <code class="highlighter-rouge">inj₂ y</code> to <code class="highlighter-rouge">inj₁ y</code>; and the <code class="highlighter-rouge">from</code>
function does the same (up to renaming). Replacing the definition of
<code class="highlighter-rouge">from∘to</code> by <code class="highlighter-rouge">λ w → refl</code> will not work; and similarly for <code class="highlighter-rouge">to∘from</code>, which
does the same (up to renaming).</p>
<pre class="Agda"><a id="⊎-comm"></a><a id="12662" href="/Connectives/#12662" class="Function">⊎-comm</a> <a id="12669" class="Symbol">:</a> <a id="12671" class="Symbol">∀</a> <a id="12673" class="Symbol">{</a><a id="12674" href="/Connectives/#12674" class="Bound">A</a> <a id="12676" href="/Connectives/#12676" class="Bound">B</a> <a id="12678" class="Symbol">:</a> <a id="12680" class="PrimitiveType">Set</a><a id="12683" class="Symbol">}</a> <a id="12685" class="Symbol">→</a> <a id="12687" class="Symbol">(</a><a id="12688" href="/Connectives/#12674" class="Bound">A</a> <a id="12690" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="12692" href="/Connectives/#12676" class="Bound">B</a><a id="12693" class="Symbol">)</a> <a id="12695" href="/Isomorphism/#4104" class="Record Operator">≃</a> <a id="12697" class="Symbol">(</a><a id="12698" href="/Connectives/#12676" class="Bound">B</a> <a id="12700" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="12702" href="/Connectives/#12674" class="Bound">A</a><a id="12703" class="Symbol">)</a>
<a id="12705" href="/Connectives/#12662" class="Function">⊎-comm</a> <a id="12712" class="Symbol">=</a> <a id="12714" class="Keyword">record</a>
  <a id="12723" class="Symbol">{</a> <a id="12725" class="Field">to</a>       <a id="12734" class="Symbol">=</a>  <a id="12737" class="Symbol">λ{</a> <a id="12740" class="Symbol">(</a><a id="12741" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="12746" href="/Connectives/#12746" class="Bound">x</a><a id="12747" class="Symbol">)</a> <a id="12749" class="Symbol">→</a> <a id="12751" class="Symbol">(</a><a id="12752" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="12757" href="/Connectives/#12746" class="Bound">x</a><a id="12758" class="Symbol">)</a>
                 <a id="12777" class="Symbol">;</a> <a id="12779" class="Symbol">(</a><a id="12780" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="12785" href="/Connectives/#12785" class="Bound">y</a><a id="12786" class="Symbol">)</a> <a id="12788" class="Symbol">→</a> <a id="12790" class="Symbol">(</a><a id="12791" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="12796" href="/Connectives/#12785" class="Bound">y</a><a id="12797" class="Symbol">)</a>
                 <a id="12816" class="Symbol">}</a>
  <a id="12820" class="Symbol">;</a> <a id="12822" class="Field">from</a>     <a id="12831" class="Symbol">=</a>  <a id="12834" class="Symbol">λ{</a> <a id="12837" class="Symbol">(</a><a id="12838" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="12843" href="/Connectives/#12843" class="Bound">y</a><a id="12844" class="Symbol">)</a> <a id="12846" class="Symbol">→</a> <a id="12848" class="Symbol">(</a><a id="12849" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="12854" href="/Connectives/#12843" class="Bound">y</a><a id="12855" class="Symbol">)</a>
                 <a id="12874" class="Symbol">;</a> <a id="12876" class="Symbol">(</a><a id="12877" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="12882" href="/Connectives/#12882" class="Bound">x</a><a id="12883" class="Symbol">)</a> <a id="12885" class="Symbol">→</a> <a id="12887" class="Symbol">(</a><a id="12888" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="12893" href="/Connectives/#12882" class="Bound">x</a><a id="12894" class="Symbol">)</a>
                 <a id="12913" class="Symbol">}</a>
  <a id="12917" class="Symbol">;</a> <a id="12919" class="Field">from∘to</a>  <a id="12928" class="Symbol">=</a>  <a id="12931" class="Symbol">λ{</a> <a id="12934" class="Symbol">(</a><a id="12935" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="12940" href="/Connectives/#12940" class="Bound">x</a><a id="12941" class="Symbol">)</a> <a id="12943" class="Symbol">→</a> <a id="12945" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
                 <a id="12967" class="Symbol">;</a> <a id="12969" class="Symbol">(</a><a id="12970" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="12975" href="/Connectives/#12975" class="Bound">y</a><a id="12976" class="Symbol">)</a> <a id="12978" class="Symbol">→</a> <a id="12980" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
                 <a id="13002" class="Symbol">}</a>
  <a id="13006" class="Symbol">;</a> <a id="13008" class="Field">to∘from</a>  <a id="13017" class="Symbol">=</a>  <a id="13020" class="Symbol">λ{</a> <a id="13023" class="Symbol">(</a><a id="13024" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="13029" href="/Connectives/#13029" class="Bound">y</a><a id="13030" class="Symbol">)</a> <a id="13032" class="Symbol">→</a> <a id="13034" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
                 <a id="13056" class="Symbol">;</a> <a id="13058" class="Symbol">(</a><a id="13059" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="13064" href="/Connectives/#13064" class="Bound">x</a><a id="13065" class="Symbol">)</a> <a id="13067" class="Symbol">→</a> <a id="13069" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
                 <a id="13091" class="Symbol">}</a>
  <a id="13095" class="Symbol">}</a></pre>
<p>Being <em>commutative</em> is different from being <em>commutative up to
isomorphism</em>.  Compare the two statements:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m + n ≡ n + m
A ⊎ B ≃ B ⊎ A
</code></pre></div></div>

<p>In the first case, we might have that <code class="highlighter-rouge">m</code> is <code class="highlighter-rouge">2</code> and <code class="highlighter-rouge">n</code> is <code class="highlighter-rouge">3</code>, and
both <code class="highlighter-rouge">m + n</code> and <code class="highlighter-rouge">n + m</code> are equal to <code class="highlighter-rouge">5</code>.  In the second case, we
might have that <code class="highlighter-rouge">A</code> is <code class="highlighter-rouge">Bool</code> and <code class="highlighter-rouge">B</code> is <code class="highlighter-rouge">Tri</code>, and <code class="highlighter-rouge">Bool ⊎ Tri</code> is
<em>not</em> the same as <code class="highlighter-rouge">Tri ⊎ Bool</code>.  But there is an isomorphism between
the two types.  For instance, <code class="highlighter-rouge">inj₁ true</code>, which is a member of the
former, corresponds to <code class="highlighter-rouge">inj₂ true</code>, which is a member of the latter.</p>

<p>For associativity, the <code class="highlighter-rouge">to</code> function reassociates, and the <code class="highlighter-rouge">from</code> function does
the inverse.  Again, the evidence of left and right inverse requires
matching against a suitable pattern to enable simplification.</p>
<pre class="Agda"><a id="⊎-assoc"></a><a id="13887" href="/Connectives/#13887" class="Function">⊎-assoc</a> <a id="13895" class="Symbol">:</a> <a id="13897" class="Symbol">∀</a> <a id="13899" class="Symbol">{</a><a id="13900" href="/Connectives/#13900" class="Bound">A</a> <a id="13902" href="/Connectives/#13902" class="Bound">B</a> <a id="13904" href="/Connectives/#13904" class="Bound">C</a> <a id="13906" class="Symbol">:</a> <a id="13908" class="PrimitiveType">Set</a><a id="13911" class="Symbol">}</a> <a id="13913" class="Symbol">→</a> <a id="13915" class="Symbol">(</a><a id="13916" href="/Connectives/#13900" class="Bound">A</a> <a id="13918" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="13920" href="/Connectives/#13902" class="Bound">B</a><a id="13921" class="Symbol">)</a> <a id="13923" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="13925" href="/Connectives/#13904" class="Bound">C</a> <a id="13927" href="/Isomorphism/#4104" class="Record Operator">≃</a> <a id="13929" href="/Connectives/#13900" class="Bound">A</a> <a id="13931" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="13933" class="Symbol">(</a><a id="13934" href="/Connectives/#13902" class="Bound">B</a> <a id="13936" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="13938" href="/Connectives/#13904" class="Bound">C</a><a id="13939" class="Symbol">)</a>
<a id="13941" href="/Connectives/#13887" class="Function">⊎-assoc</a> <a id="13949" class="Symbol">=</a> <a id="13951" class="Keyword">record</a>
  <a id="13960" class="Symbol">{</a> <a id="13962" class="Field">to</a>       <a id="13971" class="Symbol">=</a>  <a id="13974" class="Symbol">λ{</a> <a id="13977" class="Symbol">(</a><a id="13978" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="13983" class="Symbol">(</a><a id="13984" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="13989" href="/Connectives/#13989" class="Bound">x</a><a id="13990" class="Symbol">))</a> <a id="13993" class="Symbol">→</a> <a id="13995" class="Symbol">(</a><a id="13996" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="14001" href="/Connectives/#13989" class="Bound">x</a><a id="14002" class="Symbol">)</a>
                 <a id="14021" class="Symbol">;</a> <a id="14023" class="Symbol">(</a><a id="14024" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="14029" class="Symbol">(</a><a id="14030" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="14035" href="/Connectives/#14035" class="Bound">y</a><a id="14036" class="Symbol">))</a> <a id="14039" class="Symbol">→</a> <a id="14041" class="Symbol">(</a><a id="14042" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="14047" class="Symbol">(</a><a id="14048" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="14053" href="/Connectives/#14035" class="Bound">y</a><a id="14054" class="Symbol">))</a>
                 <a id="14074" class="Symbol">;</a> <a id="14076" class="Symbol">(</a><a id="14077" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="14082" href="/Connectives/#14082" class="Bound">z</a><a id="14083" class="Symbol">)</a>        <a id="14092" class="Symbol">→</a> <a id="14094" class="Symbol">(</a><a id="14095" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="14100" class="Symbol">(</a><a id="14101" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="14106" href="/Connectives/#14082" class="Bound">z</a><a id="14107" class="Symbol">))</a>
                 <a id="14127" class="Symbol">}</a>
  <a id="14131" class="Symbol">;</a> <a id="14133" class="Field">from</a>     <a id="14142" class="Symbol">=</a>  <a id="14145" class="Symbol">λ{</a> <a id="14148" class="Symbol">(</a><a id="14149" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="14154" href="/Connectives/#14154" class="Bound">x</a><a id="14155" class="Symbol">)</a>        <a id="14164" class="Symbol">→</a> <a id="14166" class="Symbol">(</a><a id="14167" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="14172" class="Symbol">(</a><a id="14173" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="14178" href="/Connectives/#14154" class="Bound">x</a><a id="14179" class="Symbol">))</a>
                 <a id="14199" class="Symbol">;</a> <a id="14201" class="Symbol">(</a><a id="14202" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="14207" class="Symbol">(</a><a id="14208" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="14213" href="/Connectives/#14213" class="Bound">y</a><a id="14214" class="Symbol">))</a> <a id="14217" class="Symbol">→</a> <a id="14219" class="Symbol">(</a><a id="14220" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="14225" class="Symbol">(</a><a id="14226" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="14231" href="/Connectives/#14213" class="Bound">y</a><a id="14232" class="Symbol">))</a>
                 <a id="14252" class="Symbol">;</a> <a id="14254" class="Symbol">(</a><a id="14255" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="14260" class="Symbol">(</a><a id="14261" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="14266" href="/Connectives/#14266" class="Bound">z</a><a id="14267" class="Symbol">))</a> <a id="14270" class="Symbol">→</a> <a id="14272" class="Symbol">(</a><a id="14273" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="14278" href="/Connectives/#14266" class="Bound">z</a><a id="14279" class="Symbol">)</a>
                 <a id="14298" class="Symbol">}</a>
  <a id="14302" class="Symbol">;</a> <a id="14304" class="Field">from∘to</a>  <a id="14313" class="Symbol">=</a>  <a id="14316" class="Symbol">λ{</a> <a id="14319" class="Symbol">(</a><a id="14320" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="14325" class="Symbol">(</a><a id="14326" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="14331" href="/Connectives/#14331" class="Bound">x</a><a id="14332" class="Symbol">))</a> <a id="14335" class="Symbol">→</a> <a id="14337" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
                 <a id="14359" class="Symbol">;</a> <a id="14361" class="Symbol">(</a><a id="14362" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="14367" class="Symbol">(</a><a id="14368" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="14373" href="/Connectives/#14373" class="Bound">y</a><a id="14374" class="Symbol">))</a> <a id="14377" class="Symbol">→</a> <a id="14379" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
                 <a id="14401" class="Symbol">;</a> <a id="14403" class="Symbol">(</a><a id="14404" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="14409" href="/Connectives/#14409" class="Bound">z</a><a id="14410" class="Symbol">)</a>        <a id="14419" class="Symbol">→</a> <a id="14421" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
                 <a id="14443" class="Symbol">}</a>
  <a id="14447" class="Symbol">;</a> <a id="14449" class="Field">to∘from</a>  <a id="14458" class="Symbol">=</a>  <a id="14461" class="Symbol">λ{</a> <a id="14464" class="Symbol">(</a><a id="14465" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="14470" href="/Connectives/#14470" class="Bound">x</a><a id="14471" class="Symbol">)</a>        <a id="14480" class="Symbol">→</a> <a id="14482" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
                 <a id="14504" class="Symbol">;</a> <a id="14506" class="Symbol">(</a><a id="14507" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="14512" class="Symbol">(</a><a id="14513" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="14518" href="/Connectives/#14518" class="Bound">y</a><a id="14519" class="Symbol">))</a> <a id="14522" class="Symbol">→</a> <a id="14524" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
                 <a id="14546" class="Symbol">;</a> <a id="14548" class="Symbol">(</a><a id="14549" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="14554" class="Symbol">(</a><a id="14555" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="14560" href="/Connectives/#14560" class="Bound">z</a><a id="14561" class="Symbol">))</a> <a id="14564" class="Symbol">→</a> <a id="14566" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
                 <a id="14588" class="Symbol">}</a>
  <a id="14592" class="Symbol">}</a></pre>

<p>Again, being <em>associative</em> is not the same as being <em>associative
up to isomorphism</em>.  For example, the type <code class="highlighter-rouge">(ℕ + Bool) + Tri</code>
is <em>not</em> the same as <code class="highlighter-rouge">ℕ + (Bool + Tri)</code>. But there is an
isomorphism between the two types. For instance <code class="highlighter-rouge">inj₂ (inj₁ true)</code>,
which is a member of the former, corresponds to <code class="highlighter-rouge">inj₁ (inj₂ true)</code>,
which is a member of the latter.</p>

<h2 id="false-is-empty">False is empty</h2>

<p>False <code class="highlighter-rouge">⊥</code> never holds.  We formalise this idea by declaring
a suitable inductive type.</p>
<pre class="Agda"><a id="15079" class="Keyword">data</a> <a id="⊥"></a><a id="15084" href="/Connectives/#15084" class="Datatype">⊥</a> <a id="15086" class="Symbol">:</a> <a id="15088" class="PrimitiveType">Set</a> <a id="15092" class="Keyword">where</a>
  <a id="15100" class="Comment">-- no clauses!</a></pre>
<p>There is no possible evidence that <code class="highlighter-rouge">⊥</code> holds.</p>

<p>Since false never holds, knowing that it holds tells us we are in a
paradoxical situation.  Given evidence that <code class="highlighter-rouge">⊥</code> holds, we might
conclude anything!  This is a basic principle of logic, known in
medieval times by the latin phrase <em>ex falso</em>, and known to children
through phrases such as “if pigs had wings, then I’d be the Queen of
Sheba”.  We formalise it as follows.</p>
<pre class="Agda"><a id="⊥-elim"></a><a id="15558" href="/Connectives/#15558" class="Function">⊥-elim</a> <a id="15565" class="Symbol">:</a> <a id="15567" class="Symbol">∀</a> <a id="15569" class="Symbol">{</a><a id="15570" href="/Connectives/#15570" class="Bound">A</a> <a id="15572" class="Symbol">:</a> <a id="15574" class="PrimitiveType">Set</a><a id="15577" class="Symbol">}</a> <a id="15579" class="Symbol">→</a> <a id="15581" href="/Connectives/#15084" class="Datatype">⊥</a> <a id="15583" class="Symbol">→</a> <a id="15585" href="/Connectives/#15570" class="Bound">A</a>
<a id="15587" href="/Connectives/#15558" class="Function">⊥-elim</a> <a id="15594" class="Symbol">()</a></pre>
<p>This is our first use of the <em>absurd pattern</em> <code class="highlighter-rouge">()</code>.
Here since <code class="highlighter-rouge">⊥</code> is a type with no members, we indicate that it is
<em>never</em> possible to match against a value of this type by using
the pattern <code class="highlighter-rouge">()</code>.</p>

<p>The nullary case of <code class="highlighter-rouge">uniq-⊎</code> is <code class="highlighter-rouge">uniq-⊥</code>, which asserts that <code class="highlighter-rouge">⊥-elim</code>
is equal to any arbitrary function from <code class="highlighter-rouge">⊥</code>.</p>
<pre class="Agda"><a id="uniq-⊥"></a><a id="15936" href="/Connectives/#15936" class="Function">uniq-⊥</a> <a id="15943" class="Symbol">:</a> <a id="15945" class="Symbol">∀</a> <a id="15947" class="Symbol">{</a><a id="15948" href="/Connectives/#15948" class="Bound">C</a> <a id="15950" class="Symbol">:</a> <a id="15952" class="PrimitiveType">Set</a><a id="15955" class="Symbol">}</a> <a id="15957" class="Symbol">(</a><a id="15958" href="/Connectives/#15958" class="Bound">h</a> <a id="15960" class="Symbol">:</a> <a id="15962" href="/Connectives/#15084" class="Datatype">⊥</a> <a id="15964" class="Symbol">→</a> <a id="15966" href="/Connectives/#15948" class="Bound">C</a><a id="15967" class="Symbol">)</a> <a id="15969" class="Symbol">(</a><a id="15970" href="/Connectives/#15970" class="Bound">w</a> <a id="15972" class="Symbol">:</a> <a id="15974" href="/Connectives/#15084" class="Datatype">⊥</a><a id="15975" class="Symbol">)</a> <a id="15977" class="Symbol">→</a> <a id="15979" href="/Connectives/#15558" class="Function">⊥-elim</a> <a id="15986" href="/Connectives/#15970" class="Bound">w</a> <a id="15988" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="15990" href="/Connectives/#15958" class="Bound">h</a> <a id="15992" href="/Connectives/#15970" class="Bound">w</a>
<a id="15994" href="/Connectives/#15936" class="Function">uniq-⊥</a> <a id="16001" href="/Connectives/#16001" class="Bound">h</a> <a id="16003" class="Symbol">()</a></pre>
<p>Using the absurd pattern asserts there are no possible values for <code class="highlighter-rouge">w</code>,
so the equation holds trivially.</p>

<p>We refer to <code class="highlighter-rouge">⊥</code> as <em>empty</em> type. And, indeed,
type <code class="highlighter-rouge">⊥</code> has no members. For example, the following function
enumerates all possible arguments of type <code class="highlighter-rouge">⊥</code>:</p>
<pre class="Agda"><a id="⊥-count"></a><a id="16289" href="/Connectives/#16289" class="Function">⊥-count</a> <a id="16297" class="Symbol">:</a> <a id="16299" href="/Connectives/#15084" class="Datatype">⊥</a> <a id="16301" class="Symbol">→</a> <a id="16303" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a>
<a id="16305" href="/Connectives/#16289" class="Function">⊥-count</a> <a id="16313" class="Symbol">()</a></pre>
<p>Here again the absurd pattern <code class="highlighter-rouge">()</code> indicates that no value can match
type <code class="highlighter-rouge">⊥</code>.</p>

<p>For numbers, zero is the identity of addition. Correspondingly,
empty is the identity of sums <em>up to isomorphism</em>.
For left identity, the <code class="highlighter-rouge">to</code> function observes that <code class="highlighter-rouge">inj₁ ()</code> can never arise,
and takes <code class="highlighter-rouge">inj₂ x</code> to <code class="highlighter-rouge">x</code>, and the <code class="highlighter-rouge">from</code> function
does the inverse.  The evidence of left inverse requires matching against
a suitable pattern to enable simplification.</p>
<pre class="Agda"><a id="⊥-identityˡ"></a><a id="16783" href="/Connectives/#16783" class="Function">⊥-identityˡ</a> <a id="16795" class="Symbol">:</a> <a id="16797" class="Symbol">∀</a> <a id="16799" class="Symbol">{</a><a id="16800" href="/Connectives/#16800" class="Bound">A</a> <a id="16802" class="Symbol">:</a> <a id="16804" class="PrimitiveType">Set</a><a id="16807" class="Symbol">}</a> <a id="16809" class="Symbol">→</a> <a id="16811" class="Symbol">(</a><a id="16812" href="/Connectives/#15084" class="Datatype">⊥</a> <a id="16814" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="16816" href="/Connectives/#16800" class="Bound">A</a><a id="16817" class="Symbol">)</a> <a id="16819" href="/Isomorphism/#4104" class="Record Operator">≃</a> <a id="16821" href="/Connectives/#16800" class="Bound">A</a>
<a id="16823" href="/Connectives/#16783" class="Function">⊥-identityˡ</a> <a id="16835" class="Symbol">=</a>
  <a id="16839" class="Keyword">record</a>
    <a id="16850" class="Symbol">{</a> <a id="16852" class="Field">to</a>       <a id="16861" class="Symbol">=</a>  <a id="16864" class="Symbol">λ{</a> <a id="16867" class="Symbol">(</a><a id="16868" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="16873" class="Symbol">())</a>
                   <a id="16896" class="Symbol">;</a> <a id="16898" class="Symbol">(</a><a id="16899" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="16904" href="/Connectives/#16904" class="Bound">x</a><a id="16905" class="Symbol">)</a> <a id="16907" class="Symbol">→</a> <a id="16909" href="/Connectives/#16904" class="Bound">x</a>
                   <a id="16930" class="Symbol">}</a>
    <a id="16936" class="Symbol">;</a> <a id="16938" class="Field">from</a>     <a id="16947" class="Symbol">=</a>  <a id="16950" class="Symbol">λ{</a> <a id="16953" href="/Connectives/#16953" class="Bound">x</a> <a id="16955" class="Symbol">→</a> <a id="16957" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="16962" href="/Connectives/#16953" class="Bound">x</a> <a id="16964" class="Symbol">}</a>
    <a id="16970" class="Symbol">;</a> <a id="16972" class="Field">from∘to</a>  <a id="16981" class="Symbol">=</a>  <a id="16984" class="Symbol">λ{</a> <a id="16987" class="Symbol">(</a><a id="16988" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="16993" class="Symbol">())</a>
                   <a id="17016" class="Symbol">;</a> <a id="17018" class="Symbol">(</a><a id="17019" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="17024" href="/Connectives/#17024" class="Bound">x</a><a id="17025" class="Symbol">)</a> <a id="17027" class="Symbol">→</a> <a id="17029" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
                   <a id="17053" class="Symbol">}</a>
    <a id="17059" class="Symbol">;</a> <a id="17061" class="Field">to∘from</a>  <a id="17070" class="Symbol">=</a>  <a id="17073" class="Symbol">λ{</a> <a id="17076" href="/Connectives/#17076" class="Bound">x</a> <a id="17078" class="Symbol">→</a> <a id="17080" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="17085" class="Symbol">}</a>
    <a id="17091" class="Symbol">}</a></pre>

<p>Having an <em>identity</em> is different from having an identity
<em>up to isomorphism</em>.  Compare the two statements:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 + m ≡ m
⊥ ⊎ A ≃ A
</code></pre></div></div>

<p>In the first case, we might have that <code class="highlighter-rouge">m</code> is <code class="highlighter-rouge">2</code>, and both <code class="highlighter-rouge">0 + m</code> and
<code class="highlighter-rouge">m</code> are equal to <code class="highlighter-rouge">2</code>.  In the second case, we might have that <code class="highlighter-rouge">A</code> is
<code class="highlighter-rouge">Bool</code>, and <code class="highlighter-rouge">⊥ ⊎ Bool</code> is <em>not</em> the same as <code class="highlighter-rouge">Bool</code>.  But there is an
isomorphism between the two types.  For instance, <code class="highlighter-rouge">inj₂ true</code>, which is
a member of the former, corresponds to <code class="highlighter-rouge">true</code>, which is a member of
the latter.</p>

<p>Right identity follows from commutativity of sum and left identity.</p>
<pre class="Agda"><a id="⊥-identityʳ"></a><a id="17686" href="/Connectives/#17686" class="Function">⊥-identityʳ</a> <a id="17698" class="Symbol">:</a> <a id="17700" class="Symbol">∀</a> <a id="17702" class="Symbol">{</a><a id="17703" href="/Connectives/#17703" class="Bound">A</a> <a id="17705" class="Symbol">:</a> <a id="17707" class="PrimitiveType">Set</a><a id="17710" class="Symbol">}</a> <a id="17712" class="Symbol">→</a> <a id="17714" class="Symbol">(</a><a id="17715" href="/Connectives/#17703" class="Bound">A</a> <a id="17717" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="17719" href="/Connectives/#15084" class="Datatype">⊥</a><a id="17720" class="Symbol">)</a> <a id="17722" href="/Isomorphism/#4104" class="Record Operator">≃</a> <a id="17724" href="/Connectives/#17703" class="Bound">A</a>
<a id="17726" href="/Connectives/#17686" class="Function">⊥-identityʳ</a> <a id="17738" class="Symbol">{</a><a id="17739" href="/Connectives/#17739" class="Bound">A</a><a id="17740" class="Symbol">}</a> <a id="17742" class="Symbol">=</a>
  <a id="17746" href="/Isomorphism/#8131" class="Function Operator">≃-begin</a>
    <a id="17758" class="Symbol">(</a><a id="17759" href="/Connectives/#17739" class="Bound">A</a> <a id="17761" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="17763" href="/Connectives/#15084" class="Datatype">⊥</a><a id="17764" class="Symbol">)</a>
  <a id="17768" href="/Isomorphism/#8195" class="Function Operator">≃⟨</a> <a id="17771" href="/Connectives/#12662" class="Function">⊎-comm</a> <a id="17778" href="/Isomorphism/#8195" class="Function Operator">⟩</a>
    <a id="17784" class="Symbol">(</a><a id="17785" href="/Connectives/#15084" class="Datatype">⊥</a> <a id="17787" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="17789" href="/Connectives/#17739" class="Bound">A</a><a id="17790" class="Symbol">)</a>
  <a id="17794" href="/Isomorphism/#8195" class="Function Operator">≃⟨</a> <a id="17797" href="/Connectives/#16783" class="Function">⊥-identityˡ</a> <a id="17809" href="/Isomorphism/#8195" class="Function Operator">⟩</a>
    <a id="17815" href="/Connectives/#17739" class="Bound">A</a>
  <a id="17819" href="/Isomorphism/#8290" class="Function Operator">≃-∎</a></pre>

<h2 id="implication">Implication is function</h2>

<p>Given two propositions <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code>, the implication <code class="highlighter-rouge">A → B</code> holds if
whenever <code class="highlighter-rouge">A</code> holds then <code class="highlighter-rouge">B</code> must also hold.  We formalise implication using
the function type, which has appeared throughout this book.</p>

<p>Evidence that <code class="highlighter-rouge">A → B</code> holds is of the form</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>λ (x : A) → N x
</code></pre></div></div>

<p>where <code class="highlighter-rouge">N x</code> is a term of type <code class="highlighter-rouge">B</code> containing as a free variable <code class="highlighter-rouge">x</code> of type <code class="highlighter-rouge">A</code>.
Given a term <code class="highlighter-rouge">L</code> providing evidence that <code class="highlighter-rouge">A → B</code> holds, and a term <code class="highlighter-rouge">M</code>
providing evidence that <code class="highlighter-rouge">A</code> holds, the term <code class="highlighter-rouge">L M</code> provides evidence that
<code class="highlighter-rouge">B</code> holds.  In other words, evidence that <code class="highlighter-rouge">A → B</code> holds is a function that
converts evidence that <code class="highlighter-rouge">A</code> holds into evidence that <code class="highlighter-rouge">B</code> holds.</p>

<p>Put another way, if we know that <code class="highlighter-rouge">A → B</code> and <code class="highlighter-rouge">A</code> both hold,
then we may conclude that <code class="highlighter-rouge">B</code> holds.</p>
<pre class="Agda"><a id="→-elim"></a><a id="18623" href="/Connectives/#18623" class="Function">→-elim</a> <a id="18630" class="Symbol">:</a> <a id="18632" class="Symbol">∀</a> <a id="18634" class="Symbol">{</a><a id="18635" href="/Connectives/#18635" class="Bound">A</a> <a id="18637" href="/Connectives/#18637" class="Bound">B</a> <a id="18639" class="Symbol">:</a> <a id="18641" class="PrimitiveType">Set</a><a id="18644" class="Symbol">}</a> <a id="18646" class="Symbol">→</a> <a id="18648" class="Symbol">(</a><a id="18649" href="/Connectives/#18635" class="Bound">A</a> <a id="18651" class="Symbol">→</a> <a id="18653" href="/Connectives/#18637" class="Bound">B</a><a id="18654" class="Symbol">)</a> <a id="18656" class="Symbol">→</a> <a id="18658" href="/Connectives/#18635" class="Bound">A</a> <a id="18660" class="Symbol">→</a> <a id="18662" href="/Connectives/#18637" class="Bound">B</a>
<a id="18664" href="/Connectives/#18623" class="Function">→-elim</a> <a id="18671" href="/Connectives/#18671" class="Bound">L</a> <a id="18673" href="/Connectives/#18673" class="Bound">M</a> <a id="18675" class="Symbol">=</a> <a id="18677" href="/Connectives/#18671" class="Bound">L</a> <a id="18679" href="/Connectives/#18673" class="Bound">M</a></pre>
<p>In medieval times, this rule was known by the name <em>modus ponens</em>.
It corresponds to function application.</p>

<p>Defining a function, with an named definition or a lambda expression,
is referred to as <em>introducing</em> a function,
while applying a function is referred to as <em>eliminating</em> the function.</p>

<p>Elimination followed by introduction is the identity.</p>
<pre class="Agda"><a id="η-→"></a><a id="19054" href="/Connectives/#19054" class="Function">η-→</a> <a id="19058" class="Symbol">:</a> <a id="19060" class="Symbol">∀</a> <a id="19062" class="Symbol">{</a><a id="19063" href="/Connectives/#19063" class="Bound">A</a> <a id="19065" href="/Connectives/#19065" class="Bound">B</a> <a id="19067" class="Symbol">:</a> <a id="19069" class="PrimitiveType">Set</a><a id="19072" class="Symbol">}</a> <a id="19074" class="Symbol">(</a><a id="19075" href="/Connectives/#19075" class="Bound">f</a> <a id="19077" class="Symbol">:</a> <a id="19079" href="/Connectives/#19063" class="Bound">A</a> <a id="19081" class="Symbol">→</a> <a id="19083" href="/Connectives/#19065" class="Bound">B</a><a id="19084" class="Symbol">)</a> <a id="19086" class="Symbol">→</a> <a id="19088" class="Symbol">(λ</a> <a id="19091" class="Symbol">(</a><a id="19092" href="/Connectives/#19092" class="Bound">x</a> <a id="19094" class="Symbol">:</a> <a id="19096" href="/Connectives/#19063" class="Bound">A</a><a id="19097" class="Symbol">)</a> <a id="19099" class="Symbol">→</a> <a id="19101" href="/Connectives/#19075" class="Bound">f</a> <a id="19103" href="/Connectives/#19092" class="Bound">x</a><a id="19104" class="Symbol">)</a> <a id="19106" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="19108" href="/Connectives/#19075" class="Bound">f</a>
<a id="19110" href="/Connectives/#19054" class="Function">η-→</a> <a id="19114" class="Symbol">{</a><a id="19115" href="/Connectives/#19115" class="Bound">A</a><a id="19116" class="Symbol">}</a> <a id="19118" class="Symbol">{</a><a id="19119" href="/Connectives/#19119" class="Bound">B</a><a id="19120" class="Symbol">}</a> <a id="19122" href="/Connectives/#19122" class="Bound">f</a> <a id="19124" class="Symbol">=</a> <a id="19126" href="/Isomorphism/#2747" class="Postulate">extensionality</a> <a id="19141" href="/Connectives/#19160" class="Function">η-helper</a>
  <a id="19152" class="Keyword">where</a>
  <a id="19160" href="/Connectives/#19160" class="Function">η-helper</a> <a id="19169" class="Symbol">:</a> <a id="19171" class="Symbol">(</a><a id="19172" href="/Connectives/#19172" class="Bound">x</a> <a id="19174" class="Symbol">:</a> <a id="19176" href="/Connectives/#19115" class="Bound">A</a><a id="19177" class="Symbol">)</a> <a id="19179" class="Symbol">→</a> <a id="19181" class="Symbol">(λ</a> <a id="19184" class="Symbol">(</a><a id="19185" href="/Connectives/#19185" class="Bound">x</a> <a id="19187" class="Symbol">:</a> <a id="19189" href="/Connectives/#19115" class="Bound">A</a><a id="19190" class="Symbol">)</a> <a id="19192" class="Symbol">→</a> <a id="19194" href="/Connectives/#19122" class="Bound">f</a> <a id="19196" href="/Connectives/#19185" class="Bound">x</a><a id="19197" class="Symbol">)</a> <a id="19199" href="/Connectives/#19172" class="Bound">x</a> <a id="19201" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="19203" href="/Connectives/#19122" class="Bound">f</a> <a id="19205" href="/Connectives/#19172" class="Bound">x</a>
  <a id="19209" href="/Connectives/#19160" class="Function">η-helper</a> <a id="19218" href="/Connectives/#19218" class="Bound">x</a> <a id="19220" class="Symbol">=</a> <a id="19222" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>
<p>The proof depends on extensionality.</p>

<!--

If we introduce an implication and then immediately eliminate it, we can
always simplify the resulting term.  Thus

    λ{ x → N } M

simplifies to `N[x := M]`, where `N[x := M]` stands for the term `N` with each
free occurrence of `x` replaced by `M`.

-->

<p>Implication binds less tightly than any other operator. Thus, <code class="highlighter-rouge">A ⊎ B →
B ⊎ A</code> parses as <code class="highlighter-rouge">(A ⊎ B) → (B ⊎ A)</code>.</p>

<p>Given two types <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code>, we refer to <code class="highlighter-rouge">A → B</code> as the <em>function</em>
space from <code class="highlighter-rouge">A</code> to <code class="highlighter-rouge">B</code>.  It is also sometimes called the <em>exponential</em>,
with <code class="highlighter-rouge">B</code> raised to the <code class="highlighter-rouge">A</code> power.  Among other reasons for calling
it the exponential, note that if type <code class="highlighter-rouge">A</code> has <code class="highlighter-rouge">m</code> distinct
members, and type <code class="highlighter-rouge">B</code> has <code class="highlighter-rouge">n</code> distinct members, then the type
<code class="highlighter-rouge">A → B</code> has <code class="highlighter-rouge">n ^ m</code> distinct members.  For instance, consider a
type <code class="highlighter-rouge">Bool</code> with two members and a type <code class="highlighter-rouge">Tri</code> with three members,
as defined earlier. The the type <code class="highlighter-rouge">Bool → Tri</code> has nine (that is,
three squared) members:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>λ{true → aa; false → aa}  λ{true → aa; false → bb}  λ{true → aa; false → cc}
λ{true → bb; false → aa}  λ{true → bb; false → bb}  λ{true → bb; false → cc}
λ{true → cc; false → aa}  λ{true → cc; false → bb}  λ{true → cc; false → cc}
</code></pre></div></div>

<p>For example, the following function enumerates all possible
arguments of the type <code class="highlighter-rouge">Bool → Tri</code>:</p>
<pre class="Agda"><a id="→-count"></a><a id="20550" href="/Connectives/#20550" class="Function">→-count</a> <a id="20558" class="Symbol">:</a> <a id="20560" class="Symbol">(</a><a id="20561" href="/Connectives/#4030" class="Datatype">Bool</a> <a id="20566" class="Symbol">→</a> <a id="20568" href="/Connectives/#4082" class="Datatype">Tri</a><a id="20571" class="Symbol">)</a> <a id="20573" class="Symbol">→</a> <a id="20575" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Nat.html#97" class="Datatype">ℕ</a>
<a id="20577" href="/Connectives/#20550" class="Function">→-count</a> <a id="20585" href="/Connectives/#20585" class="Bound">f</a> <a id="20587" class="Keyword">with</a> <a id="20592" href="/Connectives/#20585" class="Bound">f</a> <a id="20594" href="/Connectives/#4049" class="InductiveConstructor">true</a> <a id="20599" class="Symbol">|</a> <a id="20601" href="/Connectives/#20585" class="Bound">f</a> <a id="20603" href="/Connectives/#4063" class="InductiveConstructor">false</a>
<a id="20609" class="Symbol">...</a>           <a id="20623" class="Symbol">|</a> <a id="20625" href="/Connectives/#4100" class="InductiveConstructor">aa</a>    <a id="20631" class="Symbol">|</a> <a id="20633" href="/Connectives/#4100" class="InductiveConstructor">aa</a>      <a id="20641" class="Symbol">=</a>   <a id="20645" class="Number">1</a>
<a id="20647" class="Symbol">...</a>           <a id="20661" class="Symbol">|</a> <a id="20663" href="/Connectives/#4100" class="InductiveConstructor">aa</a>    <a id="20669" class="Symbol">|</a> <a id="20671" href="/Connectives/#4111" class="InductiveConstructor">bb</a>      <a id="20679" class="Symbol">=</a>   <a id="20683" class="Number">2</a>
<a id="20685" class="Symbol">...</a>           <a id="20699" class="Symbol">|</a> <a id="20701" href="/Connectives/#4100" class="InductiveConstructor">aa</a>    <a id="20707" class="Symbol">|</a> <a id="20709" href="/Connectives/#4122" class="InductiveConstructor">cc</a>      <a id="20717" class="Symbol">=</a>   <a id="20721" class="Number">3</a>
<a id="20723" class="Symbol">...</a>           <a id="20737" class="Symbol">|</a> <a id="20739" href="/Connectives/#4111" class="InductiveConstructor">bb</a>    <a id="20745" class="Symbol">|</a> <a id="20747" href="/Connectives/#4100" class="InductiveConstructor">aa</a>      <a id="20755" class="Symbol">=</a>   <a id="20759" class="Number">4</a>
<a id="20761" class="Symbol">...</a>           <a id="20775" class="Symbol">|</a> <a id="20777" href="/Connectives/#4111" class="InductiveConstructor">bb</a>    <a id="20783" class="Symbol">|</a> <a id="20785" href="/Connectives/#4111" class="InductiveConstructor">bb</a>      <a id="20793" class="Symbol">=</a>   <a id="20797" class="Number">5</a>
<a id="20799" class="Symbol">...</a>           <a id="20813" class="Symbol">|</a> <a id="20815" href="/Connectives/#4111" class="InductiveConstructor">bb</a>    <a id="20821" class="Symbol">|</a> <a id="20823" href="/Connectives/#4122" class="InductiveConstructor">cc</a>      <a id="20831" class="Symbol">=</a>   <a id="20835" class="Number">6</a>
<a id="20837" class="Symbol">...</a>           <a id="20851" class="Symbol">|</a> <a id="20853" href="/Connectives/#4122" class="InductiveConstructor">cc</a>    <a id="20859" class="Symbol">|</a> <a id="20861" href="/Connectives/#4100" class="InductiveConstructor">aa</a>      <a id="20869" class="Symbol">=</a>   <a id="20873" class="Number">7</a>
<a id="20875" class="Symbol">...</a>           <a id="20889" class="Symbol">|</a> <a id="20891" href="/Connectives/#4122" class="InductiveConstructor">cc</a>    <a id="20897" class="Symbol">|</a> <a id="20899" href="/Connectives/#4111" class="InductiveConstructor">bb</a>      <a id="20907" class="Symbol">=</a>   <a id="20911" class="Number">8</a>
<a id="20913" class="Symbol">...</a>           <a id="20927" class="Symbol">|</a> <a id="20929" href="/Connectives/#4122" class="InductiveConstructor">cc</a>    <a id="20935" class="Symbol">|</a> <a id="20937" href="/Connectives/#4122" class="InductiveConstructor">cc</a>      <a id="20945" class="Symbol">=</a>   <a id="20949" class="Number">9</a></pre>

<p>Exponential on types also share a property with exponential on
numbers in that many of the standard identities for numbers carry
over to the types.</p>

<p>Corresponding to the law</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(p ^ n) ^ m  =  p ^ (n * m)
</code></pre></div></div>

<p>we have the isomorphism</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A → (B → C)  ≃  (A × B) → C
</code></pre></div></div>

<p>Both types can be viewed as functions that given evidence that <code class="highlighter-rouge">A</code> holds
and evidence that <code class="highlighter-rouge">B</code> holds can return evidence that <code class="highlighter-rouge">C</code> holds.
This isomorphism sometimes goes by the name <em>currying</em>.
The proof of the right inverse requires extensionality.</p>
<pre class="Agda"><a id="currying"></a><a id="21491" href="/Connectives/#21491" class="Function">currying</a> <a id="21500" class="Symbol">:</a> <a id="21502" class="Symbol">∀</a> <a id="21504" class="Symbol">{</a><a id="21505" href="/Connectives/#21505" class="Bound">A</a> <a id="21507" href="/Connectives/#21507" class="Bound">B</a> <a id="21509" href="/Connectives/#21509" class="Bound">C</a> <a id="21511" class="Symbol">:</a> <a id="21513" class="PrimitiveType">Set</a><a id="21516" class="Symbol">}</a> <a id="21518" class="Symbol">→</a> <a id="21520" class="Symbol">(</a><a id="21521" href="/Connectives/#21505" class="Bound">A</a> <a id="21523" class="Symbol">→</a> <a id="21525" href="/Connectives/#21507" class="Bound">B</a> <a id="21527" class="Symbol">→</a> <a id="21529" href="/Connectives/#21509" class="Bound">C</a><a id="21530" class="Symbol">)</a> <a id="21532" href="/Isomorphism/#4104" class="Record Operator">≃</a> <a id="21534" class="Symbol">(</a><a id="21535" href="/Connectives/#21505" class="Bound">A</a> <a id="21537" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="21539" href="/Connectives/#21507" class="Bound">B</a> <a id="21541" class="Symbol">→</a> <a id="21543" href="/Connectives/#21509" class="Bound">C</a><a id="21544" class="Symbol">)</a>
<a id="21546" href="/Connectives/#21491" class="Function">currying</a> <a id="21555" class="Symbol">=</a>
  <a id="21559" class="Keyword">record</a>
    <a id="21570" class="Symbol">{</a> <a id="21572" class="Field">to</a>      <a id="21580" class="Symbol">=</a>  <a id="21583" class="Symbol">λ{</a> <a id="21586" href="/Connectives/#21586" class="Bound">f</a> <a id="21588" class="Symbol">→</a> <a id="21590" class="Symbol">λ{</a> <a id="21593" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="21595" href="/Connectives/#21595" class="Bound">x</a> <a id="21597" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="21599" href="/Connectives/#21599" class="Bound">y</a> <a id="21601" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="21603" class="Symbol">→</a> <a id="21605" href="/Connectives/#21586" class="Bound">f</a> <a id="21607" href="/Connectives/#21595" class="Bound">x</a> <a id="21609" href="/Connectives/#21599" class="Bound">y</a> <a id="21611" class="Symbol">}}</a>
    <a id="21618" class="Symbol">;</a> <a id="21620" class="Field">from</a>    <a id="21628" class="Symbol">=</a>  <a id="21631" class="Symbol">λ{</a> <a id="21634" href="/Connectives/#21634" class="Bound">g</a> <a id="21636" class="Symbol">→</a> <a id="21638" class="Symbol">λ{</a> <a id="21641" href="/Connectives/#21641" class="Bound">x</a> <a id="21643" class="Symbol">→</a> <a id="21645" class="Symbol">λ{</a> <a id="21648" href="/Connectives/#21648" class="Bound">y</a> <a id="21650" class="Symbol">→</a> <a id="21652" href="/Connectives/#21634" class="Bound">g</a> <a id="21654" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="21656" href="/Connectives/#21641" class="Bound">x</a> <a id="21658" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="21660" href="/Connectives/#21648" class="Bound">y</a> <a id="21662" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="21664" class="Symbol">}}}</a>
    <a id="21672" class="Symbol">;</a> <a id="21674" class="Field">from∘to</a> <a id="21682" class="Symbol">=</a>  <a id="21685" class="Symbol">λ{</a> <a id="21688" href="/Connectives/#21688" class="Bound">f</a> <a id="21690" class="Symbol">→</a> <a id="21692" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="21697" class="Symbol">}</a>
    <a id="21703" class="Symbol">;</a> <a id="21705" class="Field">to∘from</a> <a id="21713" class="Symbol">=</a>  <a id="21716" class="Symbol">λ{</a> <a id="21719" href="/Connectives/#21719" class="Bound">g</a> <a id="21721" class="Symbol">→</a> <a id="21723" href="/Isomorphism/#2747" class="Postulate">extensionality</a> <a id="21738" class="Symbol">λ{</a> <a id="21741" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="21743" href="/Connectives/#21743" class="Bound">x</a> <a id="21745" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="21747" href="/Connectives/#21747" class="Bound">y</a> <a id="21749" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="21751" class="Symbol">→</a> <a id="21753" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="21758" class="Symbol">}}</a>
    <a id="21765" class="Symbol">}</a></pre>

<p>Currying tells us that instead of a function that takes a pair of arguments,
we can have a function that takes the first argument and returns a function that
expects the second argument.  Thus, for instance, our way of writing addition:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_+_ : ℕ → ℕ → ℕ
</code></pre></div></div>

<p>is isomorphic to a function that accepts a pair of arguments:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_+′_ : (ℕ × ℕ) → ℕ
</code></pre></div></div>

<p>Agda is optimised for currying, so <code class="highlighter-rouge">2 + 3</code> abbreviates <code class="highlighter-rouge">_+_ 2 3</code>.
In a language optimised for pairing, we would instead take <code class="highlighter-rouge">2 +′ 3</code> as
an abbreviation for <code class="highlighter-rouge">_+′_ ⟨ 2 , 3 ⟩</code>.</p>

<p>Corresponding to the law</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p ^ (n + m) = (p ^ n) * (p ^ m)
</code></pre></div></div>

<p>we have the isomorphism</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(A ⊎ B) → C  ≃  (A → C) × (B → C)
</code></pre></div></div>

<p>That is, the assertion that if either <code class="highlighter-rouge">A</code> holds or <code class="highlighter-rouge">B</code> holds then <code class="highlighter-rouge">C</code> holds
is the same as the assertion that if <code class="highlighter-rouge">A</code> holds then <code class="highlighter-rouge">C</code> holds and if
<code class="highlighter-rouge">B</code> holds then <code class="highlighter-rouge">C</code> holds.  The proof of the left inverse requires extensionality.</p>
<pre class="Agda"><a id="→-distrib-⊎"></a><a id="22668" href="/Connectives/#22668" class="Function">→-distrib-⊎</a> <a id="22680" class="Symbol">:</a> <a id="22682" class="Symbol">∀</a> <a id="22684" class="Symbol">{</a><a id="22685" href="/Connectives/#22685" class="Bound">A</a> <a id="22687" href="/Connectives/#22687" class="Bound">B</a> <a id="22689" href="/Connectives/#22689" class="Bound">C</a> <a id="22691" class="Symbol">:</a> <a id="22693" class="PrimitiveType">Set</a><a id="22696" class="Symbol">}</a> <a id="22698" class="Symbol">→</a> <a id="22700" class="Symbol">(</a><a id="22701" href="/Connectives/#22685" class="Bound">A</a> <a id="22703" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="22705" href="/Connectives/#22687" class="Bound">B</a> <a id="22707" class="Symbol">→</a> <a id="22709" href="/Connectives/#22689" class="Bound">C</a><a id="22710" class="Symbol">)</a> <a id="22712" href="/Isomorphism/#4104" class="Record Operator">≃</a> <a id="22714" class="Symbol">((</a><a id="22716" href="/Connectives/#22685" class="Bound">A</a> <a id="22718" class="Symbol">→</a> <a id="22720" href="/Connectives/#22689" class="Bound">C</a><a id="22721" class="Symbol">)</a> <a id="22723" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="22725" class="Symbol">(</a><a id="22726" href="/Connectives/#22687" class="Bound">B</a> <a id="22728" class="Symbol">→</a> <a id="22730" href="/Connectives/#22689" class="Bound">C</a><a id="22731" class="Symbol">))</a>
<a id="22734" href="/Connectives/#22668" class="Function">→-distrib-⊎</a> <a id="22746" class="Symbol">=</a>
  <a id="22750" class="Keyword">record</a>
    <a id="22761" class="Symbol">{</a> <a id="22763" class="Field">to</a>      <a id="22771" class="Symbol">=</a> <a id="22773" class="Symbol">λ{</a> <a id="22776" href="/Connectives/#22776" class="Bound">f</a> <a id="22778" class="Symbol">→</a> <a id="22780" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="22782" href="/Connectives/#22776" class="Bound">f</a> <a id="22784" href="https://agda.github.io/agda-stdlib/Function.html#759" class="Function Operator">∘</a> <a id="22786" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="22791" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="22793" href="/Connectives/#22776" class="Bound">f</a> <a id="22795" href="https://agda.github.io/agda-stdlib/Function.html#759" class="Function Operator">∘</a> <a id="22797" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="22802" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="22804" class="Symbol">}</a>
    <a id="22810" class="Symbol">;</a> <a id="22812" class="Field">from</a>    <a id="22820" class="Symbol">=</a> <a id="22822" class="Symbol">λ{</a> <a id="22825" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="22827" href="/Connectives/#22827" class="Bound">g</a> <a id="22829" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="22831" href="/Connectives/#22831" class="Bound">h</a> <a id="22833" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="22835" class="Symbol">→</a> <a id="22837" class="Symbol">λ{</a> <a id="22840" class="Symbol">(</a><a id="22841" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="22846" href="/Connectives/#22846" class="Bound">x</a><a id="22847" class="Symbol">)</a> <a id="22849" class="Symbol">→</a> <a id="22851" href="/Connectives/#22827" class="Bound">g</a> <a id="22853" href="/Connectives/#22846" class="Bound">x</a> <a id="22855" class="Symbol">;</a> <a id="22857" class="Symbol">(</a><a id="22858" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="22863" href="/Connectives/#22863" class="Bound">y</a><a id="22864" class="Symbol">)</a> <a id="22866" class="Symbol">→</a> <a id="22868" href="/Connectives/#22831" class="Bound">h</a> <a id="22870" href="/Connectives/#22863" class="Bound">y</a> <a id="22872" class="Symbol">}</a> <a id="22874" class="Symbol">}</a>
    <a id="22880" class="Symbol">;</a> <a id="22882" class="Field">from∘to</a> <a id="22890" class="Symbol">=</a> <a id="22892" class="Symbol">λ{</a> <a id="22895" href="/Connectives/#22895" class="Bound">f</a> <a id="22897" class="Symbol">→</a> <a id="22899" href="/Isomorphism/#2747" class="Postulate">extensionality</a> <a id="22914" class="Symbol">λ{</a> <a id="22917" class="Symbol">(</a><a id="22918" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="22923" href="/Connectives/#22923" class="Bound">x</a><a id="22924" class="Symbol">)</a> <a id="22926" class="Symbol">→</a> <a id="22928" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="22933" class="Symbol">;</a> <a id="22935" class="Symbol">(</a><a id="22936" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="22941" href="/Connectives/#22941" class="Bound">y</a><a id="22942" class="Symbol">)</a> <a id="22944" class="Symbol">→</a> <a id="22946" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="22951" class="Symbol">}</a> <a id="22953" class="Symbol">}</a>
    <a id="22959" class="Symbol">;</a> <a id="22961" class="Field">to∘from</a> <a id="22969" class="Symbol">=</a> <a id="22971" class="Symbol">λ{</a> <a id="22974" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="22976" href="/Connectives/#22976" class="Bound">g</a> <a id="22978" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="22980" href="/Connectives/#22980" class="Bound">h</a> <a id="22982" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="22984" class="Symbol">→</a> <a id="22986" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="22991" class="Symbol">}</a>
    <a id="22997" class="Symbol">}</a></pre>

<p>Corresponding to the law</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(p * n) ^ m = (p ^ m) * (n ^ m)
</code></pre></div></div>

<p>we have the isomorphism</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A → B × C  ≃  (A → B) × (A → C)
</code></pre></div></div>

<p>That is, the assertion that if either <code class="highlighter-rouge">A</code> holds then <code class="highlighter-rouge">B</code> holds and <code class="highlighter-rouge">C</code> holds
is the same as the assertion that if <code class="highlighter-rouge">A</code> holds then <code class="highlighter-rouge">B</code> holds and if
<code class="highlighter-rouge">A</code> holds then <code class="highlighter-rouge">C</code> holds.  The proof of left inverse requires both extensionality
and the rule <code class="highlighter-rouge">η-×</code> for products.</p>
<pre class="Agda"><a id="→-distrib-×"></a><a id="23410" href="/Connectives/#23410" class="Function">→-distrib-×</a> <a id="23422" class="Symbol">:</a> <a id="23424" class="Symbol">∀</a> <a id="23426" class="Symbol">{</a><a id="23427" href="/Connectives/#23427" class="Bound">A</a> <a id="23429" href="/Connectives/#23429" class="Bound">B</a> <a id="23431" href="/Connectives/#23431" class="Bound">C</a> <a id="23433" class="Symbol">:</a> <a id="23435" class="PrimitiveType">Set</a><a id="23438" class="Symbol">}</a> <a id="23440" class="Symbol">→</a> <a id="23442" class="Symbol">(</a><a id="23443" href="/Connectives/#23427" class="Bound">A</a> <a id="23445" class="Symbol">→</a> <a id="23447" href="/Connectives/#23429" class="Bound">B</a> <a id="23449" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="23451" href="/Connectives/#23431" class="Bound">C</a><a id="23452" class="Symbol">)</a> <a id="23454" href="/Isomorphism/#4104" class="Record Operator">≃</a> <a id="23456" class="Symbol">(</a><a id="23457" href="/Connectives/#23427" class="Bound">A</a> <a id="23459" class="Symbol">→</a> <a id="23461" href="/Connectives/#23429" class="Bound">B</a><a id="23462" class="Symbol">)</a> <a id="23464" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="23466" class="Symbol">(</a><a id="23467" href="/Connectives/#23427" class="Bound">A</a> <a id="23469" class="Symbol">→</a> <a id="23471" href="/Connectives/#23431" class="Bound">C</a><a id="23472" class="Symbol">)</a>
<a id="23474" href="/Connectives/#23410" class="Function">→-distrib-×</a> <a id="23486" class="Symbol">=</a>
  <a id="23490" class="Keyword">record</a>
    <a id="23501" class="Symbol">{</a> <a id="23503" class="Field">to</a>      <a id="23511" class="Symbol">=</a> <a id="23513" class="Symbol">λ{</a> <a id="23516" href="/Connectives/#23516" class="Bound">f</a> <a id="23518" class="Symbol">→</a> <a id="23520" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="23522" href="/Connectives/#1703" class="Function">proj₁</a> <a id="23528" href="https://agda.github.io/agda-stdlib/Function.html#759" class="Function Operator">∘</a> <a id="23530" href="/Connectives/#23516" class="Bound">f</a> <a id="23532" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="23534" href="/Connectives/#1758" class="Function">proj₂</a> <a id="23540" href="https://agda.github.io/agda-stdlib/Function.html#759" class="Function Operator">∘</a> <a id="23542" href="/Connectives/#23516" class="Bound">f</a> <a id="23544" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="23546" class="Symbol">}</a>
    <a id="23552" class="Symbol">;</a> <a id="23554" class="Field">from</a>    <a id="23562" class="Symbol">=</a> <a id="23564" class="Symbol">λ{</a> <a id="23567" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="23569" href="/Connectives/#23569" class="Bound">g</a> <a id="23571" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="23573" href="/Connectives/#23573" class="Bound">h</a> <a id="23575" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="23577" class="Symbol">→</a> <a id="23579" class="Symbol">λ{</a> <a id="23582" href="/Connectives/#23582" class="Bound">x</a> <a id="23584" class="Symbol">→</a> <a id="23586" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="23588" href="/Connectives/#23569" class="Bound">g</a> <a id="23590" href="/Connectives/#23582" class="Bound">x</a> <a id="23592" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="23594" href="/Connectives/#23573" class="Bound">h</a> <a id="23596" href="/Connectives/#23582" class="Bound">x</a> <a id="23598" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="23600" class="Symbol">}</a> <a id="23602" class="Symbol">}</a>
    <a id="23608" class="Symbol">;</a> <a id="23610" class="Field">from∘to</a> <a id="23618" class="Symbol">=</a> <a id="23620" class="Symbol">λ{</a> <a id="23623" href="/Connectives/#23623" class="Bound">f</a> <a id="23625" class="Symbol">→</a> <a id="23627" href="/Isomorphism/#2747" class="Postulate">extensionality</a> <a id="23642" class="Symbol">λ{</a> <a id="23645" href="/Connectives/#23645" class="Bound">x</a> <a id="23647" class="Symbol">→</a> <a id="23649" href="/Connectives/#2952" class="Function">η-×</a> <a id="23653" class="Symbol">(</a><a id="23654" href="/Connectives/#23623" class="Bound">f</a> <a id="23656" href="/Connectives/#23645" class="Bound">x</a><a id="23657" class="Symbol">)</a> <a id="23659" class="Symbol">}</a> <a id="23661" class="Symbol">}</a>
    <a id="23667" class="Symbol">;</a> <a id="23669" class="Field">to∘from</a> <a id="23677" class="Symbol">=</a> <a id="23679" class="Symbol">λ{</a> <a id="23682" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="23684" href="/Connectives/#23684" class="Bound">g</a> <a id="23686" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="23688" href="/Connectives/#23688" class="Bound">h</a> <a id="23690" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="23692" class="Symbol">→</a> <a id="23694" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="23699" class="Symbol">}</a>
    <a id="23705" class="Symbol">}</a></pre>

<h2 id="distribution">Distribution</h2>

<p>Products distribute over sum, up to isomorphism.  The code to validate
this fact is similar in structure to our previous results.</p>
<pre class="Agda"><a id="×-distrib-⊎"></a><a id="23880" href="/Connectives/#23880" class="Function">×-distrib-⊎</a> <a id="23892" class="Symbol">:</a> <a id="23894" class="Symbol">∀</a> <a id="23896" class="Symbol">{</a><a id="23897" href="/Connectives/#23897" class="Bound">A</a> <a id="23899" href="/Connectives/#23899" class="Bound">B</a> <a id="23901" href="/Connectives/#23901" class="Bound">C</a> <a id="23903" class="Symbol">:</a> <a id="23905" class="PrimitiveType">Set</a><a id="23908" class="Symbol">}</a> <a id="23910" class="Symbol">→</a> <a id="23912" class="Symbol">(</a><a id="23913" href="/Connectives/#23897" class="Bound">A</a> <a id="23915" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="23917" href="/Connectives/#23899" class="Bound">B</a><a id="23918" class="Symbol">)</a> <a id="23920" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="23922" href="/Connectives/#23901" class="Bound">C</a> <a id="23924" href="/Isomorphism/#4104" class="Record Operator">≃</a> <a id="23926" class="Symbol">(</a><a id="23927" href="/Connectives/#23897" class="Bound">A</a> <a id="23929" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="23931" href="/Connectives/#23901" class="Bound">C</a><a id="23932" class="Symbol">)</a> <a id="23934" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="23936" class="Symbol">(</a><a id="23937" href="/Connectives/#23899" class="Bound">B</a> <a id="23939" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="23941" href="/Connectives/#23901" class="Bound">C</a><a id="23942" class="Symbol">)</a>
<a id="23944" href="/Connectives/#23880" class="Function">×-distrib-⊎</a> <a id="23956" class="Symbol">=</a>
  <a id="23960" class="Keyword">record</a>
    <a id="23971" class="Symbol">{</a> <a id="23973" class="Field">to</a>      <a id="23981" class="Symbol">=</a> <a id="23983" class="Symbol">λ{</a> <a id="23986" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="23988" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="23993" href="/Connectives/#23993" class="Bound">x</a> <a id="23995" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="23997" href="/Connectives/#23997" class="Bound">z</a> <a id="23999" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="24001" class="Symbol">→</a> <a id="24003" class="Symbol">(</a><a id="24004" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="24009" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="24011" href="/Connectives/#23993" class="Bound">x</a> <a id="24013" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="24015" href="/Connectives/#23997" class="Bound">z</a> <a id="24017" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a><a id="24018" class="Symbol">)</a>
                 <a id="24037" class="Symbol">;</a> <a id="24039" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="24041" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="24046" href="/Connectives/#24046" class="Bound">y</a> <a id="24048" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="24050" href="/Connectives/#24050" class="Bound">z</a> <a id="24052" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="24054" class="Symbol">→</a> <a id="24056" class="Symbol">(</a><a id="24057" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="24062" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="24064" href="/Connectives/#24046" class="Bound">y</a> <a id="24066" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="24068" href="/Connectives/#24050" class="Bound">z</a> <a id="24070" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a><a id="24071" class="Symbol">)</a>
                 <a id="24090" class="Symbol">}</a>
    <a id="24096" class="Symbol">;</a> <a id="24098" class="Field">from</a>    <a id="24106" class="Symbol">=</a> <a id="24108" class="Symbol">λ{</a> <a id="24111" class="Symbol">(</a><a id="24112" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="24117" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="24119" href="/Connectives/#24119" class="Bound">x</a> <a id="24121" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="24123" href="/Connectives/#24123" class="Bound">z</a> <a id="24125" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a><a id="24126" class="Symbol">)</a> <a id="24128" class="Symbol">→</a> <a id="24130" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="24132" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="24137" href="/Connectives/#24119" class="Bound">x</a> <a id="24139" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="24141" href="/Connectives/#24123" class="Bound">z</a> <a id="24143" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a>
                 <a id="24162" class="Symbol">;</a> <a id="24164" class="Symbol">(</a><a id="24165" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="24170" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="24172" href="/Connectives/#24172" class="Bound">y</a> <a id="24174" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="24176" href="/Connectives/#24176" class="Bound">z</a> <a id="24178" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a><a id="24179" class="Symbol">)</a> <a id="24181" class="Symbol">→</a> <a id="24183" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="24185" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="24190" href="/Connectives/#24172" class="Bound">y</a> <a id="24192" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="24194" href="/Connectives/#24176" class="Bound">z</a> <a id="24196" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a>
                 <a id="24215" class="Symbol">}</a>
    <a id="24221" class="Symbol">;</a> <a id="24223" class="Field">from∘to</a> <a id="24231" class="Symbol">=</a> <a id="24233" class="Symbol">λ{</a> <a id="24236" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="24238" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="24243" href="/Connectives/#24243" class="Bound">x</a> <a id="24245" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="24247" href="/Connectives/#24247" class="Bound">z</a> <a id="24249" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="24251" class="Symbol">→</a> <a id="24253" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
                 <a id="24275" class="Symbol">;</a> <a id="24277" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="24279" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="24284" href="/Connectives/#24284" class="Bound">y</a> <a id="24286" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="24288" href="/Connectives/#24288" class="Bound">z</a> <a id="24290" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="24292" class="Symbol">→</a> <a id="24294" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
                 <a id="24316" class="Symbol">}</a>
    <a id="24322" class="Symbol">;</a> <a id="24324" class="Field">to∘from</a> <a id="24332" class="Symbol">=</a> <a id="24334" class="Symbol">λ{</a> <a id="24337" class="Symbol">(</a><a id="24338" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="24343" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="24345" href="/Connectives/#24345" class="Bound">x</a> <a id="24347" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="24349" href="/Connectives/#24349" class="Bound">z</a> <a id="24351" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a><a id="24352" class="Symbol">)</a> <a id="24354" class="Symbol">→</a> <a id="24356" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
                 <a id="24378" class="Symbol">;</a> <a id="24380" class="Symbol">(</a><a id="24381" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="24386" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="24388" href="/Connectives/#24388" class="Bound">y</a> <a id="24390" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="24392" href="/Connectives/#24392" class="Bound">z</a> <a id="24394" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a><a id="24395" class="Symbol">)</a> <a id="24397" class="Symbol">→</a> <a id="24399" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
                 <a id="24421" class="Symbol">}</a>
    <a id="24427" class="Symbol">}</a></pre>

<p>Sums do not distribute over products up to isomorphism, but it is an embedding.</p>
<pre class="Agda"><a id="⊎-distrib-×"></a><a id="24534" href="/Connectives/#24534" class="Function">⊎-distrib-×</a> <a id="24546" class="Symbol">:</a> <a id="24548" class="Symbol">∀</a> <a id="24550" class="Symbol">{</a><a id="24551" href="/Connectives/#24551" class="Bound">A</a> <a id="24553" href="/Connectives/#24553" class="Bound">B</a> <a id="24555" href="/Connectives/#24555" class="Bound">C</a> <a id="24557" class="Symbol">:</a> <a id="24559" class="PrimitiveType">Set</a><a id="24562" class="Symbol">}</a> <a id="24564" class="Symbol">→</a> <a id="24566" class="Symbol">(</a><a id="24567" href="/Connectives/#24551" class="Bound">A</a> <a id="24569" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="24571" href="/Connectives/#24553" class="Bound">B</a><a id="24572" class="Symbol">)</a> <a id="24574" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="24576" href="/Connectives/#24555" class="Bound">C</a> <a id="24578" href="/Isomorphism/#8777" class="Record Operator">≲</a> <a id="24580" class="Symbol">(</a><a id="24581" href="/Connectives/#24551" class="Bound">A</a> <a id="24583" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="24585" href="/Connectives/#24555" class="Bound">C</a><a id="24586" class="Symbol">)</a> <a id="24588" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="24590" class="Symbol">(</a><a id="24591" href="/Connectives/#24553" class="Bound">B</a> <a id="24593" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="24595" href="/Connectives/#24555" class="Bound">C</a><a id="24596" class="Symbol">)</a>
<a id="24598" href="/Connectives/#24534" class="Function">⊎-distrib-×</a> <a id="24610" class="Symbol">=</a>
  <a id="24614" class="Keyword">record</a>
    <a id="24625" class="Symbol">{</a> <a id="24627" class="Field">to</a>      <a id="24635" class="Symbol">=</a> <a id="24637" class="Symbol">λ{</a> <a id="24640" class="Symbol">(</a><a id="24641" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="24646" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="24648" href="/Connectives/#24648" class="Bound">x</a> <a id="24650" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="24652" href="/Connectives/#24652" class="Bound">y</a> <a id="24654" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a><a id="24655" class="Symbol">)</a> <a id="24657" class="Symbol">→</a> <a id="24659" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="24661" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="24666" href="/Connectives/#24648" class="Bound">x</a> <a id="24668" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="24670" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="24675" href="/Connectives/#24652" class="Bound">y</a> <a id="24677" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a>
                 <a id="24696" class="Symbol">;</a> <a id="24698" class="Symbol">(</a><a id="24699" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="24704" href="/Connectives/#24704" class="Bound">z</a><a id="24705" class="Symbol">)</a>         <a id="24715" class="Symbol">→</a> <a id="24717" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="24719" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="24724" href="/Connectives/#24704" class="Bound">z</a> <a id="24726" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="24728" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="24733" href="/Connectives/#24704" class="Bound">z</a> <a id="24735" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a>
                 <a id="24754" class="Symbol">}</a>
    <a id="24760" class="Symbol">;</a> <a id="24762" class="Field">from</a>    <a id="24770" class="Symbol">=</a> <a id="24772" class="Symbol">λ{</a> <a id="24775" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="24777" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="24782" href="/Connectives/#24782" class="Bound">x</a> <a id="24784" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="24786" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="24791" href="/Connectives/#24791" class="Bound">y</a> <a id="24793" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="24795" class="Symbol">→</a> <a id="24797" class="Symbol">(</a><a id="24798" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="24803" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="24805" href="/Connectives/#24782" class="Bound">x</a> <a id="24807" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="24809" href="/Connectives/#24791" class="Bound">y</a> <a id="24811" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a><a id="24812" class="Symbol">)</a>
                 <a id="24831" class="Symbol">;</a> <a id="24833" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="24835" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="24840" href="/Connectives/#24840" class="Bound">x</a> <a id="24842" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="24844" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="24849" href="/Connectives/#24849" class="Bound">z</a> <a id="24851" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="24853" class="Symbol">→</a> <a id="24855" class="Symbol">(</a><a id="24856" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="24861" href="/Connectives/#24849" class="Bound">z</a><a id="24862" class="Symbol">)</a>
                 <a id="24881" class="Symbol">;</a> <a id="24883" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="24885" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="24890" href="/Connectives/#24890" class="Bound">z</a> <a id="24892" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="24894" class="Symbol">_</a>      <a id="24901" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a> <a id="24903" class="Symbol">→</a> <a id="24905" class="Symbol">(</a><a id="24906" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="24911" href="/Connectives/#24890" class="Bound">z</a><a id="24912" class="Symbol">)</a>
                 <a id="24931" class="Symbol">}</a>
    <a id="24937" class="Symbol">;</a> <a id="24939" class="Field">from∘to</a> <a id="24947" class="Symbol">=</a> <a id="24949" class="Symbol">λ{</a> <a id="24952" class="Symbol">(</a><a id="24953" href="/Connectives/#9520" class="InductiveConstructor">inj₁</a> <a id="24958" href="/Connectives/#1140" class="InductiveConstructor Operator">⟨</a> <a id="24960" href="/Connectives/#24960" class="Bound">x</a> <a id="24962" href="/Connectives/#1140" class="InductiveConstructor Operator">,</a> <a id="24964" href="/Connectives/#24964" class="Bound">y</a> <a id="24966" href="/Connectives/#1140" class="InductiveConstructor Operator">⟩</a><a id="24967" class="Symbol">)</a> <a id="24969" class="Symbol">→</a> <a id="24971" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
                 <a id="24993" class="Symbol">;</a> <a id="24995" class="Symbol">(</a><a id="24996" href="/Connectives/#9555" class="InductiveConstructor">inj₂</a> <a id="25001" href="/Connectives/#25001" class="Bound">z</a><a id="25002" class="Symbol">)</a>         <a id="25012" class="Symbol">→</a> <a id="25014" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
                 <a id="25036" class="Symbol">}</a>
    <a id="25042" class="Symbol">}</a></pre>
<p>Note that there is a choice in how we write the <code class="highlighter-rouge">from</code> function.
As given, it takes <code class="highlighter-rouge">⟨ inj₂ z , inj₂ z′ ⟩</code> to <code class="highlighter-rouge">inj₂ z</code>, but it is
easy to write a variant that instead returns <code class="highlighter-rouge">inj₂ z′</code>.  We have
an embedding rather than an isomorphism because the
<code class="highlighter-rouge">from</code> function must discard either <code class="highlighter-rouge">z</code> or <code class="highlighter-rouge">z′</code> in this case.</p>

<p>In the usual approach to logic, both of the distribution laws
are given as equivalences, where each side implies the other:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A &amp; (B ∨ C) ⇔ (A &amp; B) ∨ (A &amp; C)
A ∨ (B &amp; C) ⇔ (A ∨ B) &amp; (A ∨ C)
</code></pre></div></div>

<p>But when we consider the two laws in terms of evidence, where <code class="highlighter-rouge">_&amp;_</code>
corresponds to <code class="highlighter-rouge">_×_</code> and <code class="highlighter-rouge">_∨_</code> corresponds to <code class="highlighter-rouge">_⊎_</code>, then the first
gives rise to an isomorphism, while the second only gives rise to an
embedding, revealing a sense in which one of these laws is “more
true” than the other.</p>

<h3 id="exercise--implies-">Exercise (<code class="highlighter-rouge">⊎×-implies-×⊎</code>)</h3>

<p>Show that a disjunct of conjuncts implies a conjunct of disjuncts.</p>
<pre class="Agda"><a id="25969" class="Keyword">postulate</a>
  <a id="⊎×-implies-×⊎"></a><a id="25981" href="/Connectives/#25981" class="Postulate">⊎×-implies-×⊎</a> <a id="25995" class="Symbol">:</a> <a id="25997" class="Symbol">∀</a> <a id="25999" class="Symbol">{</a><a id="26000" href="/Connectives/#26000" class="Bound">A</a> <a id="26002" href="/Connectives/#26002" class="Bound">B</a> <a id="26004" href="/Connectives/#26004" class="Bound">C</a> <a id="26006" href="/Connectives/#26006" class="Bound">D</a> <a id="26008" class="Symbol">:</a> <a id="26010" class="PrimitiveType">Set</a><a id="26013" class="Symbol">}</a> <a id="26015" class="Symbol">→</a> <a id="26017" class="Symbol">(</a><a id="26018" href="/Connectives/#26000" class="Bound">A</a> <a id="26020" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="26022" href="/Connectives/#26002" class="Bound">B</a><a id="26023" class="Symbol">)</a> <a id="26025" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="26027" class="Symbol">(</a><a id="26028" href="/Connectives/#26004" class="Bound">C</a> <a id="26030" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="26032" href="/Connectives/#26006" class="Bound">D</a><a id="26033" class="Symbol">)</a> <a id="26035" class="Symbol">→</a> <a id="26037" class="Symbol">(</a><a id="26038" href="/Connectives/#26000" class="Bound">A</a> <a id="26040" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="26042" href="/Connectives/#26004" class="Bound">C</a><a id="26043" class="Symbol">)</a> <a id="26045" href="/Connectives/#1110" class="Datatype Operator">×</a> <a id="26047" class="Symbol">(</a><a id="26048" href="/Connectives/#26002" class="Bound">B</a> <a id="26050" href="/Connectives/#9490" class="Datatype Operator">⊎</a> <a id="26052" href="/Connectives/#26006" class="Bound">D</a><a id="26053" class="Symbol">)</a></pre>
<p>Does the converse hold? If so, prove; if not, explain why.</p>

<h3 id="exercise--refl--sym--trans">Exercise (<code class="highlighter-rouge">⇔-refl</code>, <code class="highlighter-rouge">⇔-sym</code>, <code class="highlighter-rouge">⇔-trans</code>)</h3>

<p>Define equivalence of propositions (also known as “if and only if”) as follows.</p>
<pre class="Agda"><a id="26265" class="Keyword">record</a> <a id="_⇔_"></a><a id="26272" href="/Connectives/#26272" class="Record Operator">_⇔_</a> <a id="26276" class="Symbol">(</a><a id="26277" href="/Connectives/#26277" class="Bound">A</a> <a id="26279" href="/Connectives/#26279" class="Bound">B</a> <a id="26281" class="Symbol">:</a> <a id="26283" class="PrimitiveType">Set</a><a id="26286" class="Symbol">)</a> <a id="26288" class="Symbol">:</a> <a id="26290" class="PrimitiveType">Set</a> <a id="26294" class="Keyword">where</a>
  <a id="26302" class="Keyword">field</a>
    <a id="_⇔_.to"></a><a id="26312" href="/Connectives/#26312" class="Field">to</a>   <a id="26317" class="Symbol">:</a> <a id="26319" href="/Connectives/#26277" class="Bound">A</a> <a id="26321" class="Symbol">→</a> <a id="26323" href="/Connectives/#26279" class="Bound">B</a>
    <a id="_⇔_.from"></a><a id="26329" href="/Connectives/#26329" class="Field">from</a> <a id="26334" class="Symbol">:</a> <a id="26336" href="/Connectives/#26279" class="Bound">B</a> <a id="26338" class="Symbol">→</a> <a id="26340" href="/Connectives/#26277" class="Bound">A</a></pre>
<p>Show that equivalence is reflexive, symmetric, and transitive.</p>

<h3 id="exercise--iso">Exercise (<code class="highlighter-rouge">⇔-iso</code>)</h3>

<p>Show that <code class="highlighter-rouge">A ⇔ B</code> is isomorphic to <code class="highlighter-rouge">(A → B) × (B → A)</code>.</p>

<h2 id="standard-library">Standard library</h2>

<p>Definitions similar to those in this chapter can be found in the standard library.</p>
<pre class="Agda"><a id="26617" class="Keyword">import</a> <a id="26624" href="https://agda.github.io/agda-stdlib/Data.Product.html" class="Module">Data.Product</a> <a id="26637" class="Keyword">using</a> <a id="26643" class="Symbol">(</a><a id="26644" href="https://agda.github.io/agda-stdlib/Data.Product.html#1329" class="Function Operator">_×_</a><a id="26647" class="Symbol">;</a> <a id="26649" href="https://agda.github.io/agda-stdlib/Data.Product.html#559" class="Field">proj₁</a><a id="26654" class="Symbol">;</a> <a id="26656" href="https://agda.github.io/agda-stdlib/Data.Product.html#573" class="Field">proj₂</a><a id="26661" class="Symbol">)</a> <a id="26663" class="Keyword">renaming</a> <a id="26672" class="Symbol">(</a><a id="26673" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">_,_</a> <a id="26677" class="Symbol">to</a> <a id="26680" href="https://agda.github.io/agda-stdlib/Data.Product.html#543" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="26685" class="Symbol">)</a>
<a id="26687" class="Keyword">import</a> <a id="26694" href="https://agda.github.io/agda-stdlib/Data.Unit.html" class="Module">Data.Unit</a> <a id="26704" class="Keyword">using</a> <a id="26710" class="Symbol">(</a><a id="26711" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Unit.html#69" class="Record">⊤</a><a id="26712" class="Symbol">;</a> <a id="26714" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Unit.html#106" class="InductiveConstructor">tt</a><a id="26716" class="Symbol">)</a>
<a id="26718" class="Keyword">import</a> <a id="26725" href="https://agda.github.io/agda-stdlib/Data.Sum.html" class="Module">Data.Sum</a> <a id="26734" class="Keyword">using</a> <a id="26740" class="Symbol">(</a><a id="26741" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#414" class="Datatype Operator">_⊎_</a><a id="26744" class="Symbol">;</a> <a id="26746" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#470" class="InductiveConstructor">inj₁</a><a id="26750" class="Symbol">;</a> <a id="26752" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#495" class="InductiveConstructor">inj₂</a><a id="26756" class="Symbol">)</a> <a id="26758" class="Keyword">renaming</a> <a id="26767" class="Symbol">(</a><a id="26768" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#721" class="Function Operator">[_,_]</a> <a id="26774" class="Symbol">to</a> <a id="26777" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#721" class="Function Operator">⊎-elim</a><a id="26783" class="Symbol">)</a>
<a id="26785" class="Keyword">import</a> <a id="26792" href="https://agda.github.io/agda-stdlib/Data.Empty.html" class="Module">Data.Empty</a> <a id="26803" class="Keyword">using</a> <a id="26809" class="Symbol">(</a><a id="26810" href="https://agda.github.io/agda-stdlib/Data.Empty.html#243" class="Datatype">⊥</a><a id="26811" class="Symbol">;</a> <a id="26813" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a><a id="26819" class="Symbol">)</a></pre>
<p>The standard library constructs pairs with <code class="highlighter-rouge">_,_</code> whereas we use <code class="highlighter-rouge">⟨_,_⟩</code>.
The former makes it convenient to make triples or larger tuples from pairs,
permitting <code class="highlighter-rouge">a , b , c</code> to stand for <code class="highlighter-rouge">(a , (b , c))</code>.  But it conflicts with
other useful notations, such as <code class="highlighter-rouge">[_,_]</code> and <code class="highlighter-rouge">[_,_,_]</code> to construct
lists of two or three elements in
Chapter <a href="/Lists/">Lists</a>
or <code class="highlighter-rouge">Γ , A</code> to extend environments in
Chapter <a href="/DeBruijn/">DeBruijn</a>.</p>

<h2 id="unicode">Unicode</h2>

<p>This chapter uses the following unicode.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>×  U+00D7  MULTIPLICATION SIGN (\x)
⊎  U+228E  MULTISET UNION (\u+)
⊤  U+22A4  DOWN TACK (\top)
⊥  U+22A5  UP TACK (\bot)
η  U+03B7  GREEK SMALL LETTER ETA (\eta)
₁  U+2081  SUBSCRIPT ONE (\_1)
₂  U+2082  SUBSCRIPT TWO (\_2)
⇔  U+21D4  LEFT RIGHT DOUBLE ARROW (\&lt;=&gt;)
</code></pre></div></div>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Programming Language Foundations in Agda
</h2><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wenkokke"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wenkokke</span></a></li><li><a href="https://www.twitter.com/wenkokke"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wenkokke</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wadler"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wadler</span></a></li><li><a href="https://www.twitter.com/philipwadler"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">philipwadler</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div></div>

</footer>
<!-- Import jQuery -->
<script type="text/javascript" src="/assets/jquery.js"></script>

<!-- Script which allows for foldable code blocks -->
<script type="text/javascript">
 $('div.foldable pre').each(function(){
     var autoHeight = $(this).height();
     var lineHeight = parseFloat($(this).css('line-height'));

     var plus    = $("<div></div>");
     var horLine = $("<div></div>");
     var verLine = $("<div></div>");
     $(this).prepend(plus);
     plus.css({
         'position'         : 'relative',
         'float'            : 'right',
         'right'            : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'width'            : lineHeight,
         'height'           : lineHeight});
     verLine.css({
         'position'         : 'relative',
         'height'           : lineHeight,
         'width'            : '3px',
         'background-color' : '#C1E0FF'});
     horLine.css({
         'position'         : 'relative',
         'top'              : '-' + (0.5 * lineHeight + 1.5) + 'px',
         'left'             : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'height'           : '3px',
         'width'            : lineHeight,
         'background-color' : '#C1E0FF'});
     plus.append(verLine);
     plus.append(horLine);

     $(this).height(2.0 * lineHeight);
     $(this).css('overflow','hidden');

     $(this).click(function(){
         if ($(this).height() == autoHeight) {
             $(this).height(2.0 * lineHeight);
             plus.show();
         }
         else {
             $(this).height('auto');
             plus.hide();
         }
     });
 });
</script>

<!-- Import KaTeX -->
<script type="text/javascript" src="/assets/katex.js"></script>

<!-- Script which renders TeX using KaTeX -->
<script type="text/javascript">
 $("script[type='math/tex']").replaceWith(
     function(){
         var tex = $(this).text();
         return "<span class=\"inline-equation\">" +
                katex.renderToString(tex) +
                "</span>";
     });
 $("script[type='math/tex; mode=display']").replaceWith(
     function(){
         var tex = $(this).text().replace(/%.*?(\n|$)/g,"");
         return "<div class=\"equation\">" +
                katex.renderToString("\\displaystyle "+tex) +
                "</div>";
     });
</script>
</body>

</html>
